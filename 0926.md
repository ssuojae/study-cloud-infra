## 목차

1. [목차1]()


<br/>
<br/>

## 주요 포트

| 포트 번호 | 프로토콜         | 역할 및 설명                                                                                   | 보안성               | 주 사용 사례                                      | TCP/UDP 사용 |
|-----------|------------------|------------------------------------------------------------------------------------------------|----------------------|--------------------------------------------------|--------------|
| 20        | FTP (데이터)      | **FTP 데이터 전송** 포트. FTP 액티브 모드에서 파일 전송에 사용됨.                                         | 낮음                 | 파일 전송 (액티브 모드)                            | TCP          |
| 21        | FTP (제어)        | **FTP 제어 포트**. 명령어와 제어 메시지 전송에 사용됨. 파일 목록 조회, 로그인 등의 명령을 처리.                      | 낮음                 | FTP 파일 전송 제어                                 | TCP          |
| 22        | SSH               | **SSH(Secure Shell)** 포트. 암호화된 원격 접속과 파일 전송을 제공.                                    | 높음 (암호화)         | 원격 로그인, 서버 관리, 파일 전송 (SCP, SFTP)         | TCP          |
| 23        | Telnet            | **Telnet** 포트. 원격 시스템 접속용이나, 암호화되지 않은 평문 통신이기 때문에 보안에 매우 취약함.                  | 매우 낮음 (평문)      | 과거 원격 접속, 현재는 사용이 거의 중단됨               | TCP          |
| 53        | DNS               | **DNS(Domain Name System)** 포트. 도메인 이름을 IP 주소로 변환하기 위해 사용됨.                          | 중간 (평문 통신, 일부 보안 기능) | 도메인 이름 해석, 네트워크에서 IP 주소 관리              | TCP/UDP      |
| 110       | POP3              | **POP3(Post Office Protocol v3)** 포트. 이메일 수신을 위한 프로토콜로, 메일을 서버에서 클라이언트로 가져옴.           | 낮음 (암호화 없음)   | 이메일 클라이언트가 메일 서버에서 메일을 다운로드할 때     | TCP          |
| 143       | IMAP              | **IMAP(Internet Message Access Protocol)** 포트. 이메일 수신 프로토콜로, 서버에서 메일을 직접 관리하며 다수의 클라이언트에서 동기화 가능. | 중간 (암호화 가능)   | 이메일 클라이언트가 메일 서버에서 메일을 동기화하고 관리할 때 | TCP          |
| 443       | HTTPS             | **HTTPS(Hypertext Transfer Protocol Secure)** 포트. HTTP에 **SSL/TLS**를 적용해 암호화된 안전한 웹 트래픽 제공. | 높음 (암호화)         | 웹 브라우징(보안 웹사이트 접속), 안전한 데이터 전송            | TCP          |

<br/>
<br/>


## TCP와 UDP 모두 사용하는 DNS

| 프로토콜  | 사용 시점                                    | 이유 및 설명                                                                                  |
|-----------|----------------------------------------------|------------------------------------------------------------------------------------------------|
| UDP       | 일반적인 DNS 쿼리 (최대 512바이트 이하)         | **빠른 전송**을 위해 UDP 사용. DNS 쿼리 대부분이 짧은 요청/응답 패킷으로 이루어지므로 연결 설정이 필요 없는 UDP가 효율적. |
| TCP       | 데이터 크기가 512바이트를 초과하거나 영역 전송(Zone Transfer) | **대용량 데이터 전송**이 필요하거나 신뢰성 있는 연결이 필요한 경우 TCP 사용. TCP는 패킷 순서 보장과 오류 검출 가능.   |

- **UDP 사용 이유**: 
  - **빠른 응답**이 중요하기 때문에, 일반적인 DNS 쿼리 응답은 연결 설정이 필요 없는 **UDP**로 처리. 대부분의 DNS 응답은 512바이트 이하로 작아 UDP로 충분히 처리 가능.
  - UDP는 네트워크 부하가 적고 속도가 빠르므로, DNS 서버가 대량의 요청을 효율적으로 처리할 수 있다.
  
- **TCP 사용 이유**: 
  - **대용량 응답** 또는 **특수 작업**(예: **DNS 영역 전송(Zone Transfer)**)에서는 UDP의 한계를 넘기 때문에, **TCP**로 전환해 **데이터의 신뢰성**을 보장한다. TCP는 패킷이 순서대로 도착하도록 보장하고, 오류 검출 및 재전송 기능을 제공한다.
  - 512바이트를 초과하는 응답(예: **DNSSEC** 사용 시)이나, TCP 연결이 필요할 정도로 중요한 요청에서는 **TCP**가 사용된다.


<br/>

## POP 방식과 IMAP 방식 비교 (네이버 메일을 삭제하지 않아도 되는 이유)

| 구분          | POP3 (Post Office Protocol v3)                                      | IMAP (Internet Message Access Protocol)                                 |
|---------------|---------------------------------------------------------------------|-------------------------------------------------------------------------|
| **동작 방식** | 메일을 **서버에서 클라이언트로 다운로드**하여 로컬에서 관리.              | 메일을 서버에 **저장**하고, 클라이언트에서 **동기화**하여 관리.               |
| **서버와의 동기화** | 서버에서 메일을 다운로드한 후에는 서버에서 해당 메일이 삭제됨.           | 메일이 **서버에 남아있어**, 여러 클라이언트에서 동일하게 접근 가능.          |
| **여러 기기 사용**  | 하나의 기기에서만 메일 확인 가능 (다른 기기에서 메일을 확인할 수 없음). | 여러 기기에서 메일을 동기화하여 접근 가능 (PC, 스마트폰 등).              |
| **폴더 관리**   | 로컬에 저장된 메일만 관리 가능. 서버에 저장된 메일 폴더는 지원하지 않음.    | 서버에 저장된 메일 폴더를 그대로 관리 가능 (메일 폴더 구조 유지).          |
| **메일 상태**   | 클라이언트로 다운로드된 후 메일은 **읽음 상태**로 처리됨.                  | 메일이 서버에 남아있고, 읽음/안 읽음 상태가 **동기화**됨.                   |
| **연결 방식**   | 메일을 다운로드한 후 **오프라인**에서도 메일을 확인할 수 있음.             | 서버에 **연결된 상태**에서만 모든 메일을 확인 가능 (오프라인에서는 일부 제한). |
| **저장 공간**   | 클라이언트 로컬에 메일이 저장되므로 서버의 저장 공간을 절약할 수 있음.     | 메일이 서버에 남아있으므로 **서버 저장 공간**을 차지함.                     |
| **보안**       | 메일이 로컬에 저장되므로, 로컬 장치의 보안에 의존함.                       | 메일이 서버에 저장되어 **서버 측 보안**이 중요.                             |
| **대표 사용 사례** | 메일을 한 번만 확인하고, 로컬에서 저장해 관리하려는 사용자가 적합.          | 여러 기기에서 메일을 지속적으로 관리, 동기화하려는 사용자가 적합.            |

<br/>
<br/>

## 리눅스 파일 권한과 `chmod` 명령어 정리

### 1. 리눅스 파일 권한 기본 개념

리눅스에서 파일 권한은 **소유자**, **그룹**, **기타 사용자**로 구분되며, 각각에 대해 **읽기(Read)**, **쓰기(Write)**, **실행(Execute)** 권한을 설정할 수 있다.

#### 권한의 구성 요소
- **읽기 권한 (r)**: 파일을 **읽을 수 있는** 권한.
- **쓰기 권한 (w)**: 파일을 **수정할 수 있는** 권한.
- **실행 권한 (x)**: 파일을 **실행할 수 있는** 권한. 스크립트나 프로그램의 경우 필요.

#### 파일 권한 구조 예시
```bash
$ ls -l
-rwxr-xr-- 1 user group 1024 Sep 26 10:00 example.sh
```
- -: 파일 타입 (일반 파일은 -, 디렉터리는 d)
- rwx: 소유자(User)의 권한 (읽기, 쓰기, 실행)
- r-x: 그룹(Group)의 권한 (읽기, 실행)
- r--: 기타 사용자(Other)의 권한 (읽기만 가능)


#### 파일 권한이 분산화 환경에서 중요한 이유

분산화 환경에서는 **여러 시스템과 사용자가 같은 파일이나 디렉터리**에 접근하는 상황이 빈번하다. 이때 파일 권한을 제대로 설정하지 않으면, **데이터 손실**, **보안 문제**, **잘못된 수정** 등이 발생할 수 있다. 따라서 **파일 권한 관리**는 다음과 같은 이유로 매우 중요하다.

1. **데이터 보안**
분산 시스템에서는 여러 VM이나 사용자들이 **공유 자원**에 접근하게 된다. 이때 특정 파일에 **누가 접근할 수 있는지** 명확히 설정하지 않으면, 중요한 데이터가 **의도치 않게 수정**되거나 **유출**될 수 있다.

2. **데이터 무결성 보호**
여러 VM이나 사용자가 **동시에 하나의 파일을 수정**할 수 있는 경우, 파일의 **무결성**이 깨질 수 있다. 이를 방지하기 위해, **특정 사용자나 VM만 쓰기 권한을 부여**하여 데이터의 수정 권한을 제한할 수 있다.

3. **협업 환경에서의 역할 분담**
분산 시스템에서는 여러 사용자가 각기 다른 역할을 맡고 있기 때문에, **각자의 역할에 맞는 파일 권한**을 부여해야 한다. 예를 들어, 관리자에게는 **모든 권한**을 부여하고, 일반 사용자에게는 **읽기 권한만** 부여하는 식으로 접근을 제어할 수 있다.


#### 3. `chmod`와 파일 권한을 통한 분산화 환경 관리

1. **접근 제한을 통한 보안 강화**
`chmod` 명령어를 사용하여 **파일에 접근할 수 있는 사용자 그룹**을 세분화하고, **특정 사용자 또는 그룹에게만 파일을 수정하거나 실행할 권한**을 부여할 수 있다. 이를 통해 여러 VM이 같은 자원에 접근하더라도 **필요한 사용자만 권한을 갖게 되어 보안**이 강화된다.

**예시**
- VM1은 **읽기 권한만** 가지도록 설정 (`chmod u-w,o+r file.txt`).
- VM2는 **읽기와 쓰기 권한**을 가지도록 설정 (`chmod u+rw file.txt`).

2. **공유 자원의 통제**
분산화 환경에서는 **공유 디렉터리**를 통해 여러 VM이 같은 파일에 접근하는 경우가 많다. 이때 파일 권한을 통해 **각 VM이 읽기만 가능하게 할지, 쓰기도 가능하게 할지**를 결정할 수 있다. 이를 통해 중요한 파일의 수정 권한을 **특정 사용자나 프로세스에 한정**할 수 있다.

3. **프로세스 간 자원 접근 제한**
분산화 시스템에서는 여러 프로세스가 동시에 실행되고 있을 수 있다. 이때 **특정 프로세스나 VM만 파일에 접근할 수 있도록** 권한을 설정하면, 불필요한 접근을 차단할 수 있다. 예를 들어, VM1에서 실행되는 백업 프로세스는 **읽기 권한**만 가지게 하고, VM2에서 실행되는 관리자는 **쓰기 권한**도 가질 수 있다.



#### 4. 실제 분산 시스템에서의 파일 권한 관리 사례

1. **분산 스토리지 시스템**
분산 스토리지 시스템에서 각 노드(Node)가 **데이터 블록**을 관리할 때, 각 노드의 접근 권한을 설정하여 **데이터 무결성을 보호**할 수 있다. **쓰기 권한이 있는 노드만 데이터를 수정**할 수 있고, 다른 노드는 **읽기만 가능**하도록 설정하여 안전하게 데이터를 관리한다.

2. **클라우드 기반 협업 시스템**
여러 개발자나 팀이 **같은 클라우드 환경**에서 협업할 때, 파일 권한을 설정하여 각 팀원에게 **필요한 파일만 접근**할 수 있도록 관리할 수 있다. 예를 들어, 팀 A는 파일을 읽기만 가능하게 설정하고, 팀 B는 파일을 수정할 수 있는 권한을 부여한다.

<br/>
<br/>


## 리눅스 파일 시스템의 주체: 사용자(user), 그룹(group), 기타 사용자(other)

리눅스 파일 시스템에서 **파일 접근 권한**은 크게 세 가지 주체에 의해 결정된다: **사용자(User)**, **그룹(Group)**, **기타 사용자(Other)**. 각각의 주체가 해당 파일에 대해 **어떤 권한**을 가질 수 있는지에 따라 시스템의 보안과 접근이 관리된다.

<br/>

### 1. 사용자 (User)
- **사용자**는 파일이나 디렉터리를 **소유한 주체**를 의미한다. 파일을 만든 사용자가 기본적으로 해당 파일의 소유자가 된다.
- 각 사용자는 고유한 **사용자 계정**을 가지고 있으며, 이를 통해 시스템에 로그인하고 **파일이나 디렉터리**에 대한 접근 권한을 관리한다.
- 파일 소유자는 그 파일에 대해 **읽기(r)**, **쓰기(w)**, **실행(x)** 권한을 가질 수 있으며, 이 권한은 다른 사용자와 공유되지 않는다.

#### 사용자 관련 명령어
- **`whoami`**: 현재 로그인한 사용자를 확인.
    ```bash
    $ whoami
    ```
- **`chown`**: 파일이나 디렉터리의 소유자를 변경.
    ```bash
    $ sudo chown newuser filename
    ```

<br/>

### 2. 그룹 (Group)
- **그룹**은 여러 사용자를 하나의 그룹으로 묶어 **공통된 권한을 부여**하는 개념이다.
- 여러 사용자가 함께 프로젝트를 진행하거나 협업할 때, 같은 그룹에 속한 사용자들에게 **파일에 대한 동일한 권한**을 부여할 수 있다.
- 각 사용자는 하나 이상의 그룹에 속할 수 있으며, 그룹에 속한 사용자들은 **그룹 권한**에 따라 파일이나 디렉터리에 접근할 수 있다.

#### 그룹 관련 명령어
- **`groups`**: 현재 사용자가 속한 그룹을 확인.
    ```bash
    $ groups
    ```
- **`chgrp`**: 파일이나 디렉터리의 그룹을 변경.
    ```bash
    $ sudo chgrp groupname filename
    ```

<br/>

### 3. 기타 사용자 (Other)
- **기타 사용자(other)** 는 파일 소유자나 그 파일이 속한 그룹에 포함되지 않은 **모든 사용자**를 의미한다.
- 시스템에서 로그인한 사용자 중 **해당 파일의 소유자도 아니고 그룹에도 속하지 않은 모든 사용자들**이 기타 사용자로 분류된다.
- 기타 사용자에게는 보통 **읽기 권한**만 부여하거나 **접근을 제한**할 수 있다. 이를 통해 시스템의 **보안**을 강화하고, 민감한 파일에 대한 접근을 막을 수 있다.

#### 기타 사용자 관련 명령어
- **`chmod`**: 기타 사용자의 권한을 설정할 수 있다. 예를 들어, 기타 사용자에게 **읽기 권한**만 주려면:
    ```bash
    $ chmod o+r filename
    ```

<br/>

### 정리: 리눅스 파일 시스템에서의 권한 주체 구조
리눅스 파일 시스템은 파일에 대한 **접근 권한**을 세 가지 주체로 나눠서 관리한다.

1. **소유자 (User)**:
    - 파일을 만든 사용자로, 해당 파일에 대한 **읽기, 쓰기, 실행** 권한을 가질 수 있다.

2. **그룹 (Group)**:
    - 파일이 속한 그룹에 속한 사용자들로, 그룹에 속한 사용자들은 **읽기, 쓰기, 실행** 권한을 가질 수 있다.

3. **기타 사용자 (Other)**:
    - 소유자와 그룹에 속하지 않은 **모든 사용자들**. 이 사용자들에게는 보통 **읽기 권한**만 부여하거나, **접근을 차단**할 수 있다.

### 리눅스 파일 권한 관련 예시
리눅스에서 파일 권한을 설정하고 관리할 때, 각 주체에 따라 권한을 다르게 설정할 수 있다.

#### `chmod` 명령어를 사용하여 권한 변경
- 소유자에게 **읽기, 쓰기, 실행** 권한을 모두 부여하고, 그룹과 기타 사용자에게 **읽기 권한**만 부여하려면:
    ```bash
    chmod 744 filename
    ```
    - **7**: 소유자에게 **읽기(r)**, **쓰기(w)**, **실행(x)** 권한 모두 부여.
    - **4**: 그룹에게 **읽기 권한**만 부여.
    - **4**: 기타 사용자에게 **읽기 권한**만 부여.

<br/>
<br/>

## `umask`란?

**`umask`(User File Creation Mask)** 는 **리눅스**에서 새롭게 파일이나 디렉터리를 생성할 때의 **기본 권한을 설정**하는 데 사용되는 값이다. **파일의 기본 권한**에서 `umask` 값이 차감되어, 최종적인 파일 권한이 결정된다.

<br/>

### 1. `umask`의 역할

- **파일 생성 시 기본 권한을 설정**: 
  - 새 파일이나 디렉터리를 만들 때, `umask`에 설정된 값이 적용되어 기본 권한이 설정된다.
  - 기본적으로는 **보안상의 이유로 모든 권한이 허용되지 않고** 일부 권한이 차감되어 파일이 생성된다.

#### 기본 권한
- **파일의 기본 권한**: `666` (읽기 및 쓰기 권한, 실행 권한 없음)
- **디렉터리의 기본 권한**: `777` (읽기, 쓰기, 실행 권한 모두 허용)

**`umask`** 값은 기본 권한에서 **차감되는 권한**을 정의하며, 예를 들어 `umask 022`는 **쓰기 권한**을 그룹과 기타 사용자로부터 차감한다.

<br/>

### 2. `umask` 기본 동작

#### `umask` 값이 적용되는 방식
- **파일 생성 시 기본 권한 = 기본 권한 - umask 값**
- 예를 들어, 기본 파일 권한이 **666**이고 `umask` 값이 **022**라면:
  - 기본 권한 `666`에서 `022`를 차감 → 최종 권한 **644**
  - 즉, **소유자는 읽기/쓰기 권한**, **그룹과 기타 사용자는 읽기 권한만** 갖게 된다.

#### 디렉터리 생성 시
- 디렉터리는 기본적으로 **`777`** 권한을 가진다.
- 예를 들어, `umask`가 **002**라면:
  - 기본 디렉터리 권한 `777`에서 `002`를 차감 → 최종 권한 **775**
  - 즉, **소유자와 그룹은 읽기/쓰기/실행 권한**을, **기타 사용자는 읽기/실행 권한**을 갖는다.

<br/>

### 3. `umask` 값 확인 및 설정

#### 현재 `umask` 값 확인
```bash
$ umask
```
- 현재 설정된 umask 값을 확인할 수 있다. 일반적으로 002나 022로 설정되어 있다.

#### umask 값 설정

```bash
$ umask 022
```

- 022는 그룹과 기타 사용자에게 쓰기 권한을 주지 않는 설정을 의미한다.
- 002는 기타 사용자에게만 쓰기 권한을 제한하며, 그룹은 읽기/쓰기/실행 권한을 가진다.

<br/>

### **요약**
- `umask`는 새로 생성된 파일이나 디렉터리의 **기본 권한을 설정**하는 데 중요한 역할을 한다.
- 파일의 기본 권한에서 **`umask` 값을 차감**하여 최종 권한이 결정되며, 보안 및 시스템 관리에서 자주 사용된다.
- **`umask` 값을 확인하고 설정**함으로써, 새로 생성되는 파일에 대한 권한을 효율적으로 제어할 수 있다.

<br/>
<br/>

## `mactime`이란?

- `mactime` 은 리눅스/유닉스 환경에서 **파일 시스템의 타임스탬프 정보**를 분석하여 **파일의 생성 시간, 마지막 수정 시간, 마지막 접근 시간**을 타임라인 형식으로 보여주는 도구이다.
  특히, **디지털 포렌식**에서 시스템의 활동 내역을 분석하는 데 자주 사용된다.

<br/>

### 1. `mactime`에서 사용하는 타임스탬프 정보

`mactime` 도구는 **파일 시스템**에서 파일 및 디렉터리의 **세 가지 시간 정보**를 사용한다:

1. **M (Modification time, 수정 시간)**  
   - 파일이 마지막으로 **수정된 시간**을 나타낸다. 파일의 **내용**이 변경될 때 업데이트된다.

2. **A (Access time, 접근 시간)**  
   - 파일이 마지막으로 **읽히거나 접근된 시간**을 나타낸다. 파일을 읽거나 실행할 때 업데이트된다.

3. **C (Change time, 변경 시간)**  
   - 파일의 **메타데이터**(예: 권한, 소유자)가 마지막으로 **변경된 시간**을 나타낸다. 파일의 **속성**이 변경될 때 업데이트된다.

<br/>


### 2. `mactime` 사용 방법

`mactime`은 파일 시스템의 타임스탬프 정보를 수집하여, 그 정보를 바탕으로 **파일 시스템 활동의 타임라인**을 생성한다.

#### 예시: `mactime` 타임라인 생성
1. **타임라인 생성**
   - 파일 시스템에서 타임스탬프 정보를 수집하고 이를 이용해 타임라인을 생성한다.
   ```bash
   mactime -b bodyfile > timeline.txt
   ```

여기서 **bodyfile**은 타임스탬프 정보가 저장된 파일이며, **timeline.txt**는 생성된 타임라인 정보가 저장될 파일이다.

타임라인 분석
생성된 타임라인 파일은 파일 시스템의 파일 및 디렉터리가 언제 생성, 수정, 접근되었는지에 대한 정보를 제공한다.

<br/>

### 3. mactime의 활용 사례

mactime은 주로 디지털 포렌식 및 시스템 감사에서 사용되며, 파일 시스템의 활동 내역을 추적하는 데 유용하다.

1) 디지털 포렌식
해킹이나 보안 침해 사건에서, 파일이 언제 접근되었고 수정되었는지를 분석할 수 있다.
이를 통해 공격자의 활동 시간이나 변조된 파일을 추적할 수 있다.

3) 시스템 감사
시스템 관리자가 시스템에서 어떤 파일들이 수정되거나 접근되었는지 확인하고, 비정상적인 활동을 감지할 수 있다.

5) 보안 분석
시스템이 침해당한 시점과 공격자가 수정한 파일을 시간 순으로 추적하여 보안 위협을 분석하는 데 사용된다.

4. mactime의 필요성
파일 시스템에서 파일 활동 내역을 시간 순서대로 기록하여 분석하는 데 필수적인 도구이다.
보안 및 디지털 포렌식에서 파일의 생성, 수정, 접근 시간을 통해 비정상적인 활동을 파악하고 시스템 내 문제를 추적하는 데 도움이 된다.

6. mactime의 한계
mactime은 파일 시스템에서 제공하는 타임스탬프 정보만을 분석할 수 있으므로, 타임스탬프가 변경되거나 조작된 경우에는 분석의 정확도가 떨어질 수 있다.
따라서, 타임스탬프가 조작된 흔적이 있거나 파일이 삭제된 경우 추가적인 분석 도구와 함께 사용되어야 한다.

<br/>
<br/>


## mactime 명령어 사용 

### 1. `mactime` 사용 과정

#### Step 1: 파일 시스템에서 타임스탬프 정보 수집

먼저, **`fls`** 명령어를 사용해 **파일 시스템의 타임스탬프 정보**를 수집한다. 이 정보는 **bodyfile**이라는 파일로 저장된다.

```bash
fls -r /path/to/diskimage > bodyfile
```

- **`fls`**: 파일 시스템에서 파일 정보를 출력하는 도구
- **`-r`**: **재귀적으로** 모든 파일 및 디렉터리 정보를 가져옴
- **`/path/to/diskimage`**: 분석하고자 하는 디스크 이미지나 파일 시스템 경로
- **`bodyfile`**: 타임스탬프 정보가 저장되는 파일

<br/>

#### Step 2: `mactime`을 사용해 타임라인 생성

**`mactime`** 명령어를 사용하여 **bodyfile**에 저장된 타임스탬프 정보를 **타임라인**으로 변환

```bash
mactime -b bodyfile > timeline.txt
```

- **`-b`**: bodyfile을 사용하여 타임라인을 생성
- **`timeline.txt`**: 결과 타임라인이 저장될 파일

<br/>

### 2. `mactime` 결과 예시

**`timeline.txt`** 파일에 저장된 결과는 **파일 시스템의 타임스탬프 정보**가 시간순으로 정렬되어 표시됩니다. 각 파일의 **수정 시간(M)**, **접근 시간(A)**, **변경 시간(C)** 정보가 포함

#### 타임라인 결과 예시:

```plaintext
Date       Size     Type     Mode        UID   GID     Meta      File Name
-----------------------------------------------------------------------------------
2024-09-26 12:34:56 1024     r/rrwxrwxrwx   0     0     *INODE*   /path/to/file1.txt
2024-09-26 12:34:56 4096     d/drwxr-xr-x   1000  1000  *INODE*   /path/to/directory
2024-09-26 12:35:20 512      r/rrw-r--r--   1000  1000  *INODE*   /path/to/file2.log
2024-09-26 12:40:30 2048     r/rrw-r--r--   1000  1000  *INODE*   /path/to/file3.conf
```

<br/>

### 3. `mactime`의 실무 적용 예시

#### 시나리오:
디지털 포렌식에서 **침해 사고**가 발생하고 시스템의 **특정 파일**이 언제 수정되었고, 누가 접근했는지 조사해야 하는 상황일때, 시스템 관리자는 **`mactime`** 을 통해 파일 시스템의 **타임라인을 분석**하여 파일 활동을 추적할 수 있다.

#### 명령어 실행

```bash
fls -r /mnt/disk > bodyfile
mactime -b bodyfile > timeline.txt
```

#### 결과 

```plaintext
2024-09-26 12:34:56 1024     r/rrwxrwxrwx   0     0     *INODE*   /home/user/.bash_history
2024-09-26 12:40:20 2048     r/rrw-r--r--   1000  1000  *INODE*   /var/log/auth.log
2024-09-26 12:50:00 512      r/rrw-r--r--   1000  1000  *INODE*   /home/user/malicious_script.sh
```

- **`/home/user/.bash_history`**: **2024년 9월 26일 12:34:56**에 **수정됨**.
- **`/var/log/auth.log`**: **2024년 9월 26일 12:40:20**에 **접근됨**.
- **`/home/user/malicious_script.sh`**: **2024년 9월 26일 12:50:00**에 **수정됨**.

<br/>
<br/>


## 리눅스 파일 시스템 구조 설명


```bash
Root directory
/
├── bin      : 기본 명령어 실행 파일 저장소
├── boot     : 부팅 관련 파일 저장소
├── dev      : 장치 파일 저장소
├── etc      : 설정 파일 저장소
├── home     : 사용자 개인 파일 저장소
├── lib      : 시스템 라이브러리 파일 저장소
├── media    : 외부 장치 마운트 포인트
├── mnt      : 임시 마운트 포인트
├── opt      : 추가 소프트웨어 설치 디렉터리
├── proc     : 실시간 시스템 정보 저장소 (가상 파일 시스템)
├── root     : 루트 사용자의 홈 디렉터리
├── sbin     : 시스템 관리 명령어 저장소
├── tmp      : 임시 파일 저장소
├── usr      : 사용자 명령어와 애플리케이션 저장소
│   ├── bin   : 추가 명령어 저장소
│   ├── lib   : 추가 라이브러리 저장소
│   └── share : 공용 데이터 저장소
└── var      : 가변 데이터 저장소
    ├── log   : 로그 파일 저장소
    └── spool : 프린터 대기열 등 가변 데이터 저장소
```


### 주요 디렉터리 설명

1. **`/` (루트 디렉터리)**:
   - 리눅스 파일 시스템의 최상위 디렉터리로, 모든 파일과 디렉터리가 이곳에 포함된다.
   
2. **`/bin`: 기본 명령어 실행 파일 저장소**:
   - 시스템 운영에 필요한 기본 명령어 실행 파일들이 저장된 곳. `ls`, `cp`, `mv`와 같은 필수 명령어가 여기에 위치한다.

3. **`/boot`: 부팅 관련 파일 저장소**:
   - 리눅스 커널과 부트로더 설정 파일이 저장된 곳으로, 시스템이 부팅될 때 이 파일들이 사용된다.

4. **`/dev`: 장치 파일 저장소**:
   - 시스템의 하드웨어 장치를 나타내는 파일들이 저장된 곳. 하드디스크, 터미널, 프린터와 같은 장치들이 파일로 표현된다.

5. **`/etc`: 설정 파일 저장소**:
   - 시스템과 서비스의 구성 파일들이 저장된 디렉터리. 네트워크 설정, 사용자 계정 정보, 시스템 서비스 설정 등이 여기에 저장된다.

6. **`/home`: 사용자 개인 파일 저장소**:
   - 각 사용자의 홈 디렉터리가 저장된 곳으로, 개인 파일과 설정들이 보관된다.

7. **`/lib`: 시스템 라이브러리 파일 저장소**:
   - 프로그램 실행에 필요한 공유 라이브러리 파일들이 위치한 곳이다.

8. **`/media` & `/mnt`: 외부 장치 마운트 포인트**:
   - 외부 장치(USB, CD-ROM)가 연결될 때 이곳에 마운트되어 접근할 수 있게 된다.

9. **`/opt`: 추가 소프트웨어 저장소**:
   - 선택적으로 설치한 애플리케이션이나 소프트웨어 패키지들이 저장된다.

10. **`/proc`: 실시간 시스템 정보 저장소**:
    - 커널과 프로세스 정보가 실시간으로 저장되는 가상 파일 시스템이다.

11. **`/root`: 루트 사용자의 홈 디렉터리**:
    - 루트 사용자의 개인 파일들이 저장된 디렉터리.

12. **`/sbin`: 시스템 관리 명령어 저장소**:
    - 시스템 관리자가 사용하는 시스템 관리 명령어들이 저장된 디렉터리.

13. **`/tmp`: 임시 파일 저장소**:
    - 프로그램들이 실행 중에 생성하는 임시 파일들이 저장된 곳으로, 재부팅 시 파일들이 삭제된다.

14. **`/usr`: 사용자 명령어와 애플리케이션 저장소**:
    - 시스템에서 사용되는 추가 애플리케이션과 명령어들이 여기에 저장된다. `/usr/bin`, `/usr/lib`, `/usr/share`와 같은 하위 디렉터리로 나뉜다.

15. **`/var`: 가변 데이터 저장소**:
    - 로그 파일, 이메일 큐, 프린터 대기열과 같은 자주 변경되는 데이터가 저장되는 디렉터리. 특히, 시스템 로그 파일이 `/var/log`에 저장된다.

<br/>
<br/>

## 리눅스 사용자 및 그룹 관리 파일과 명령어

- **`/etc/passwd`**, **`/etc/shadow`**, 그리고 **`/etc/group`** 은 리눅스 OS에서 **사용자 계정과 그룹 정보를 저장하고 관리**하는 파일들이다.
- 이 파일들은 리눅스의 **사용자 정보**, **그룹 정보**, **암호 설정**을 관리하는 **시스템 파일**들이다.

<br/>

### 1. 파일들의 역할

#### `/etc/passwd`: 사용자 계정 정보 저장 파일
- **사용자 계정에 대한 기본 정보**를 저장하는 파일.
- 사용자 이름, 사용자 ID(UID), 그룹 ID(GID), 홈 디렉터리, 로그인 셸 등의 정보가 기록된다.

#### `/etc/shadow`: 암호 정보 저장 파일
- 사용자 계정의 암호 정보를 저장하는 파일. 보안상의 이유로 암호화된 비밀번호와 암호 만료 정보가 포함되어 있으며, 이 파일은 **루트 사용자만 접근** 할 수 있다.

#### `/etc/group`: 그룹 정보 저장 파일
- 그룹 정보를 저장하는 파일. **그룹 이름**, **그룹 ID(GID)**, **그룹에 속한 사용자 목록**이 저장된다.

<br/>

### 2. 관련 명령어들

이 파일들을 직접 수정하는 대신, 다음 명령어들을 통해 **계정 관리**나 **그룹 관리** 작업을 수행할 수 있다.

#### **사용자 계정 관리 명령어**

- **`useradd`, `usermod`, `userdel`**: 사용자를 추가, 수정, 삭제하는 명령어들.
    - **예시**: 
      ```bash
      sudo useradd username  # 새로운 사용자 추가
      ```
      이 명령어를 실행하면 **/etc/passwd**와 **/etc/shadow**에 사용자 정보가 반영된다.

- **`passwd`**: 사용자의 비밀번호를 설정하거나 변경하는 명령어.
    - **예시**: 
      ```bash
      passwd username  # 사용자의 비밀번호 변경
      ```
      이 명령어는 **/etc/shadow** 파일에 비밀번호 정보를 저장한다.

#### **그룹 관리 명령어**

- **`groupadd`, `groupmod`, `groupdel`**: 그룹을 추가, 수정, 삭제하는 명령어들.
    - **예시**: 
      ```bash
      sudo groupadd groupname  # 새로운 그룹 추가
      ```
      이 명령어를 통해 **/etc/group** 에 그룹 정보가 반영된다.
      
<br/>
<br/>

## 리눅스 특수 권한: setuid, setgid, sticky bit

| 특수 권한  | 역할                                                                                             | 네이밍 의미                                                      | 설정 방법             | 확인 방법               |
|------------|--------------------------------------------------------------------------------------------------|------------------------------------------------------------------|-----------------------|-------------------------|
| **setuid** | 파일이 실행될 때 **파일 소유자의 권한**으로 실행되도록 함.                                         | **Set User ID**: 실행 시 소유자의 사용자 ID로 실행됨.            | `chmod u+s filename`  | `ls -l`에서 **s** 표시   |
| **setgid** | - **파일**: 파일이 **소유 그룹의 권한**으로 실행됨. <br> - **디렉터리**: 생성된 파일이 **부모 디렉터리의 그룹**을 상속받음. | **Set Group ID**: 실행 시 소유 그룹 ID로 실행되거나 상속됨.     | `chmod g+s directory` | `ls -l`에서 **s** 표시   |
| **Sticky Bit** | 디렉터리 내에서 **파일 소유자만 그 파일을 삭제**할 수 있게 제한함.                               | **Sticky**: 파일을 디렉터리에 고정시켜 소유자 외에 삭제 불가.   | `chmod +t directory`  | `ls -l`에서 **t** 표시   |


- 리눅스에서 **특수 권한**은 **setuid**, **setgid**, **sticky bit**로 구성어 있다.
- 이 권한들은 특정한 상황에서 파일이나 디렉터리에 대한 **보안** 및 **접근 제어**를 강화하는 데 사용된다.

<br/>

### 1. setuid (Set User ID)

- **setuid**는 파일에 적용되는 특수 권한으로, 파일이 실행될 때 해당 파일의 **소유자 권한**으로 실행되도록 한다.
- 일반적으로 **root 사용자**가 소유한 프로그램이 **setuid**로 설정되면, 해당 프로그램을 실행하는 모든 사용자는 **root 권한**으로 실행할 수 있다.

#### 사용 예시:
- **passwd** 명령어는 **setuid**가 설정된 프로그램으로, 일반 사용자도 **root 권한**을 임시로 획득하여 자신의 비밀번호를 변경할 수 있다.

#### setuid 설정 방법:
```bash
chmod u+s filename
```

#### setuid 확인:
파일의 권한을 확인하면, 실행 권한 부분에 **s**가 표시된다.
```bash
ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 421K Sep  26 14:00 /usr/bin/passwd
```

<br/>

### 2. setgid (Set Group ID)
setgid는 파일 또는 디렉터리에 적용되며, 파일의 경우 그 파일이 실행될 때 해당 파일이 속한 그룹 권한으로 실행된다. 디렉터리의 경우, 해당 디렉터리 내에서 생성되는 모든 파일이나 디렉터리는 부모 디렉터리의 그룹 소유권을 상속받는다.

#### 사용 예시:
- 공유 디렉터리에서 사용되며, 디렉터리 내에서 생성된 파일들이 자동으로 동일한 그룹을 가지도록 설정할 수 있다.
setgid 설정 방법:
```bash
chmod g+s directory_name
```
setgid 확인:
파일이나 디렉터리의 권한에서 **s**가 표시된다.

```bash
ls -l directory_name
drwxr-sr-x 2 user group 4096 Sep  26 14:00 directory_name
```

<br/>

### 3. Sticky Bit (스티키 비트)
Sticky Bit는 디렉터리에 적용되며, 디렉터리의 모든 사용자가 파일을 생성하거나 수정할 수 있지만, 자신이 소유한 파일만 삭제할 수 있도록 제한하는 특수 권한이다. 주로 공유 디렉터리에서 다른 사용자가 실수로 파일을 삭제하지 못하도록 설정할 때 사용된다.

#### 사용 예시:
/tmp 디렉터리는 sticky bit가 설정되어 있어, 모든 사용자가 파일을 생성할 수 있지만, 자신이 소유한 파일만 삭제할 수 있다.
sticky bit 설정 방법:

```bash
chmod +t directory_name
```
sticky bit 확인:
디렉터리의 권한에서 **t**가 표시된다.
```bash
ls -l /tmp
drwxrwxrwt 10 root root 4096 Sep 26 14:00 /tmp
```

<br/>

### 4. 주의할 점

- 리눅스에서 **특수 권한 설정**은 파일 자체의 내용을 변경하는 것이 아니라, **파일 시스템의 권한 정보**를 조작하여 **누가 해당 파일이나 디렉터리에 접근할 수 있는지**를 결정하는 과정이다.
- 이를 비유하자면, 파일은 **방 안의 물건**이고, 권한 설정은 그 방에 걸린 **자물쇠**라고 할 수 있다. **chmod**와 같은 명령어는 이 자물쇠를 설정하거나 변경하여, 특정 사용자나 그룹이 그 방을 열 수 있는 **열쇠**를 부여하는 것과 같다.
- **setuid**는 파일을 실행하는 사용자가 **파일 소유자의 권한**으로 실행되게 하여 **주인의 열쇠**로 문을 여는 것이고, **setgid**는 **그룹의 열쇠**로 문을 열 수 있도록 설정하는 것이다.
**sticky bit**는 공유된 디렉터리에서 **각자 자신의 파일만 삭제**할 수 있도록 **자물쇠를 설정하는 것**과 같은 역할을 한다.
  이러한 권한 설정을 통해 리눅스는 **사용자와 그룹 간의 권한 관리**를 유연하게 할 수 있게 된다.







