## 목차

1. [목차1]()


<br/>
<br/>

## 주요 포트

| 포트 번호 | 프로토콜         | 역할 및 설명                                                                                   | 보안성               | 주 사용 사례                                      | TCP/UDP 사용 |
|-----------|------------------|------------------------------------------------------------------------------------------------|----------------------|--------------------------------------------------|--------------|
| 20        | FTP (데이터)      | **FTP 데이터 전송** 포트. FTP 액티브 모드에서 파일 전송에 사용됨.                                         | 낮음                 | 파일 전송 (액티브 모드)                            | TCP          |
| 21        | FTP (제어)        | **FTP 제어 포트**. 명령어와 제어 메시지 전송에 사용됨. 파일 목록 조회, 로그인 등의 명령을 처리.                      | 낮음                 | FTP 파일 전송 제어                                 | TCP          |
| 22        | SSH               | **SSH(Secure Shell)** 포트. 암호화된 원격 접속과 파일 전송을 제공.                                    | 높음 (암호화)         | 원격 로그인, 서버 관리, 파일 전송 (SCP, SFTP)         | TCP          |
| 23        | Telnet            | **Telnet** 포트. 원격 시스템 접속용이나, 암호화되지 않은 평문 통신이기 때문에 보안에 매우 취약함.                  | 매우 낮음 (평문)      | 과거 원격 접속, 현재는 사용이 거의 중단됨               | TCP          |
| 53        | DNS               | **DNS(Domain Name System)** 포트. 도메인 이름을 IP 주소로 변환하기 위해 사용됨.                          | 중간 (평문 통신, 일부 보안 기능) | 도메인 이름 해석, 네트워크에서 IP 주소 관리              | TCP/UDP      |
| 110       | POP3              | **POP3(Post Office Protocol v3)** 포트. 이메일 수신을 위한 프로토콜로, 메일을 서버에서 클라이언트로 가져옴.           | 낮음 (암호화 없음)   | 이메일 클라이언트가 메일 서버에서 메일을 다운로드할 때     | TCP          |
| 143       | IMAP              | **IMAP(Internet Message Access Protocol)** 포트. 이메일 수신 프로토콜로, 서버에서 메일을 직접 관리하며 다수의 클라이언트에서 동기화 가능. | 중간 (암호화 가능)   | 이메일 클라이언트가 메일 서버에서 메일을 동기화하고 관리할 때 | TCP          |
| 443       | HTTPS             | **HTTPS(Hypertext Transfer Protocol Secure)** 포트. HTTP에 **SSL/TLS**를 적용해 암호화된 안전한 웹 트래픽 제공. | 높음 (암호화)         | 웹 브라우징(보안 웹사이트 접속), 안전한 데이터 전송            | TCP          |

<br/>
<br/>


## TCP와 UDP 모두 사용하는 DNS

| 프로토콜  | 사용 시점                                    | 이유 및 설명                                                                                  |
|-----------|----------------------------------------------|------------------------------------------------------------------------------------------------|
| UDP       | 일반적인 DNS 쿼리 (최대 512바이트 이하)         | **빠른 전송**을 위해 UDP 사용. DNS 쿼리 대부분이 짧은 요청/응답 패킷으로 이루어지므로 연결 설정이 필요 없는 UDP가 효율적. |
| TCP       | 데이터 크기가 512바이트를 초과하거나 영역 전송(Zone Transfer) | **대용량 데이터 전송**이 필요하거나 신뢰성 있는 연결이 필요한 경우 TCP 사용. TCP는 패킷 순서 보장과 오류 검출 가능.   |

- **UDP 사용 이유**: 
  - **빠른 응답**이 중요하기 때문에, 일반적인 DNS 쿼리 응답은 연결 설정이 필요 없는 **UDP**로 처리. 대부분의 DNS 응답은 512바이트 이하로 작아 UDP로 충분히 처리 가능.
  - UDP는 네트워크 부하가 적고 속도가 빠르므로, DNS 서버가 대량의 요청을 효율적으로 처리할 수 있다.
  
- **TCP 사용 이유**: 
  - **대용량 응답** 또는 **특수 작업**(예: **DNS 영역 전송(Zone Transfer)**)에서는 UDP의 한계를 넘기 때문에, **TCP**로 전환해 **데이터의 신뢰성**을 보장한다. TCP는 패킷이 순서대로 도착하도록 보장하고, 오류 검출 및 재전송 기능을 제공한다.
  - 512바이트를 초과하는 응답(예: **DNSSEC** 사용 시)이나, TCP 연결이 필요할 정도로 중요한 요청에서는 **TCP**가 사용된다.


<br/>

## POP 방식과 IMAP 방식 비교 (네이버 메일을 삭제하지 않아도 되는 이유)

| 구분          | POP3 (Post Office Protocol v3)                                      | IMAP (Internet Message Access Protocol)                                 |
|---------------|---------------------------------------------------------------------|-------------------------------------------------------------------------|
| **동작 방식** | 메일을 **서버에서 클라이언트로 다운로드**하여 로컬에서 관리.              | 메일을 서버에 **저장**하고, 클라이언트에서 **동기화**하여 관리.               |
| **서버와의 동기화** | 서버에서 메일을 다운로드한 후에는 서버에서 해당 메일이 삭제됨.           | 메일이 **서버에 남아있어**, 여러 클라이언트에서 동일하게 접근 가능.          |
| **여러 기기 사용**  | 하나의 기기에서만 메일 확인 가능 (다른 기기에서 메일을 확인할 수 없음). | 여러 기기에서 메일을 동기화하여 접근 가능 (PC, 스마트폰 등).              |
| **폴더 관리**   | 로컬에 저장된 메일만 관리 가능. 서버에 저장된 메일 폴더는 지원하지 않음.    | 서버에 저장된 메일 폴더를 그대로 관리 가능 (메일 폴더 구조 유지).          |
| **메일 상태**   | 클라이언트로 다운로드된 후 메일은 **읽음 상태**로 처리됨.                  | 메일이 서버에 남아있고, 읽음/안 읽음 상태가 **동기화**됨.                   |
| **연결 방식**   | 메일을 다운로드한 후 **오프라인**에서도 메일을 확인할 수 있음.             | 서버에 **연결된 상태**에서만 모든 메일을 확인 가능 (오프라인에서는 일부 제한). |
| **저장 공간**   | 클라이언트 로컬에 메일이 저장되므로 서버의 저장 공간을 절약할 수 있음.     | 메일이 서버에 남아있으므로 **서버 저장 공간**을 차지함.                     |
| **보안**       | 메일이 로컬에 저장되므로, 로컬 장치의 보안에 의존함.                       | 메일이 서버에 저장되어 **서버 측 보안**이 중요.                             |
| **대표 사용 사례** | 메일을 한 번만 확인하고, 로컬에서 저장해 관리하려는 사용자가 적합.          | 여러 기기에서 메일을 지속적으로 관리, 동기화하려는 사용자가 적합.            |

<br/>
<br/>

## 리눅스 파일 권한과 `chmod` 명령어 정리

### 1. 리눅스 파일 권한 기본 개념

<img width="1475" alt="image" src="https://github.com/user-attachments/assets/a12b1798-2922-4bd7-ae95-c885dbbe813b">

리눅스에서 파일 권한은 **소유자**, **그룹**, **기타 사용자**로 구분되며, 각각에 대해 **읽기(Read)**, **쓰기(Write)**, **실행(Execute)** 권한을 설정할 수 있다.

#### 권한의 구성 요소
- **읽기 권한 (r)**: 파일을 **읽을 수 있는** 권한.
- **쓰기 권한 (w)**: 파일을 **수정할 수 있는** 권한.
- **실행 권한 (x)**: 파일을 **실행할 수 있는** 권한. 스크립트나 프로그램의 경우 필요.

#### 파일 권한 구조 예시
```bash
$ ls -l
-rwxr-xr-- 1 user group 1024 Sep 26 10:00 example.sh
```
- -: 파일 타입 (일반 파일은 -, 디렉터리는 d)
- rwx: 소유자(User)의 권한 (읽기, 쓰기, 실행)
- r-x: 그룹(Group)의 권한 (읽기, 실행)
- r--: 기타 사용자(Other)의 권한 (읽기만 가능)


#### 파일 권한이 분산화 환경에서 중요한 이유

분산화 환경에서는 **여러 시스템과 사용자가 같은 파일이나 디렉터리**에 접근하는 상황이 빈번하다. 이때 파일 권한을 제대로 설정하지 않으면, **데이터 손실**, **보안 문제**, **잘못된 수정** 등이 발생할 수 있다. 따라서 **파일 권한 관리**는 다음과 같은 이유로 매우 중요하다.

1. **데이터 보안**
분산 시스템에서는 여러 VM이나 사용자들이 **공유 자원**에 접근하게 된다. 이때 특정 파일에 **누가 접근할 수 있는지** 명확히 설정하지 않으면, 중요한 데이터가 **의도치 않게 수정**되거나 **유출**될 수 있다.

2. **데이터 무결성 보호**
여러 VM이나 사용자가 **동시에 하나의 파일을 수정**할 수 있는 경우, 파일의 **무결성**이 깨질 수 있다. 이를 방지하기 위해, **특정 사용자나 VM만 쓰기 권한을 부여**하여 데이터의 수정 권한을 제한할 수 있다.

3. **협업 환경에서의 역할 분담**
분산 시스템에서는 여러 사용자가 각기 다른 역할을 맡고 있기 때문에, **각자의 역할에 맞는 파일 권한**을 부여해야 한다. 예를 들어, 관리자에게는 **모든 권한**을 부여하고, 일반 사용자에게는 **읽기 권한만** 부여하는 식으로 접근을 제어할 수 있다.


#### 3. `chmod`와 파일 권한을 통한 분산화 환경 관리

1. **접근 제한을 통한 보안 강화**

<img width="700" alt="image" src="https://github.com/user-attachments/assets/1a9b9b12-bd6f-43f7-829d-660574aa1265">

<img width="700" alt="image" src="https://github.com/user-attachments/assets/5a9e9420-6eca-4d70-9eee-099579ec3bbb">

`chmod` 명령어를 사용하여 **파일에 접근할 수 있는 사용자 그룹**을 세분화하고, **특정 사용자 또는 그룹에게만 파일을 수정하거나 실행할 권한**을 부여할 수 있다. 이를 통해 여러 VM이 같은 자원에 접근하더라도 **필요한 사용자만 권한을 갖게 되어 보안**이 강화된다.

**예시**
- VM1은 **읽기 권한만** 가지도록 설정 (`chmod u-w,o+r file.txt`).
- VM2는 **읽기와 쓰기 권한**을 가지도록 설정 (`chmod u+rw file.txt`).

2. **공유 자원의 통제**
분산화 환경에서는 **공유 디렉터리**를 통해 여러 VM이 같은 파일에 접근하는 경우가 많다. 이때 파일 권한을 통해 **각 VM이 읽기만 가능하게 할지, 쓰기도 가능하게 할지**를 결정할 수 있다. 이를 통해 중요한 파일의 수정 권한을 **특정 사용자나 프로세스에 한정**할 수 있다.

3. **프로세스 간 자원 접근 제한**
분산화 시스템에서는 여러 프로세스가 동시에 실행되고 있을 수 있다. 이때 **특정 프로세스나 VM만 파일에 접근할 수 있도록** 권한을 설정하면, 불필요한 접근을 차단할 수 있다. 예를 들어, VM1에서 실행되는 백업 프로세스는 **읽기 권한**만 가지게 하고, VM2에서 실행되는 관리자는 **쓰기 권한**도 가질 수 있다.



#### 4. 실제 분산 시스템에서의 파일 권한 관리 사례

1. **분산 스토리지 시스템**
분산 스토리지 시스템에서 각 노드(Node)가 **데이터 블록**을 관리할 때, 각 노드의 접근 권한을 설정하여 **데이터 무결성을 보호**할 수 있다. **쓰기 권한이 있는 노드만 데이터를 수정**할 수 있고, 다른 노드는 **읽기만 가능**하도록 설정하여 안전하게 데이터를 관리한다.

2. **클라우드 기반 협업 시스템**
여러 개발자나 팀이 **같은 클라우드 환경**에서 협업할 때, 파일 권한을 설정하여 각 팀원에게 **필요한 파일만 접근**할 수 있도록 관리할 수 있다. 예를 들어, 팀 A는 파일을 읽기만 가능하게 설정하고, 팀 B는 파일을 수정할 수 있는 권한을 부여한다.

<br/>
<br/>


## 리눅스 파일 시스템의 주체: 사용자(user), 그룹(group), 기타 사용자(other)

리눅스 파일 시스템에서 **파일 접근 권한**은 크게 세 가지 주체에 의해 결정된다: **사용자(User)**, **그룹(Group)**, **기타 사용자(Other)**. 각각의 주체가 해당 파일에 대해 **어떤 권한**을 가질 수 있는지에 따라 시스템의 보안과 접근이 관리된다.

<br/>

### 1. 사용자 (User)
- **사용자**는 파일이나 디렉터리를 **소유한 주체**를 의미한다. 파일을 만든 사용자가 기본적으로 해당 파일의 소유자가 된다.
- 각 사용자는 고유한 **사용자 계정**을 가지고 있으며, 이를 통해 시스템에 로그인하고 **파일이나 디렉터리**에 대한 접근 권한을 관리한다.
- 파일 소유자는 그 파일에 대해 **읽기(r)**, **쓰기(w)**, **실행(x)** 권한을 가질 수 있으며, 이 권한은 다른 사용자와 공유되지 않는다.

#### 사용자 관련 명령어
- **`whoami`**: 현재 로그인한 사용자를 확인.
    ```bash
    $ whoami
    ```
- **`chown`**: 파일이나 디렉터리의 소유자를 변경.
    ```bash
    $ sudo chown newuser filename
    ```

<br/>

### 2. 그룹 (Group)
- **그룹**은 여러 사용자를 하나의 그룹으로 묶어 **공통된 권한을 부여**하는 개념이다.
- 여러 사용자가 함께 프로젝트를 진행하거나 협업할 때, 같은 그룹에 속한 사용자들에게 **파일에 대한 동일한 권한**을 부여할 수 있다.
- 각 사용자는 하나 이상의 그룹에 속할 수 있으며, 그룹에 속한 사용자들은 **그룹 권한**에 따라 파일이나 디렉터리에 접근할 수 있다.

#### 그룹 관련 명령어
- **`groups`**: 현재 사용자가 속한 그룹을 확인.
    ```bash
    $ groups
    ```
- **`chgrp`**: 파일이나 디렉터리의 그룹을 변경.
    ```bash
    $ sudo chgrp groupname filename
    ```

<br/>

### 3. 기타 사용자 (Other)
- **기타 사용자(other)** 는 파일 소유자나 그 파일이 속한 그룹에 포함되지 않은 **모든 사용자**를 의미한다.
- 시스템에서 로그인한 사용자 중 **해당 파일의 소유자도 아니고 그룹에도 속하지 않은 모든 사용자들**이 기타 사용자로 분류된다.
- 기타 사용자에게는 보통 **읽기 권한**만 부여하거나 **접근을 제한**할 수 있다. 이를 통해 시스템의 **보안**을 강화하고, 민감한 파일에 대한 접근을 막을 수 있다.

#### 기타 사용자 관련 명령어
- **`chmod`**: 기타 사용자의 권한을 설정할 수 있다. 예를 들어, 기타 사용자에게 **읽기 권한**만 주려면:
    ```bash
    $ chmod o+r filename
    ```

<br/>

### 정리: 리눅스 파일 시스템에서의 권한 주체 구조
리눅스 파일 시스템은 파일에 대한 **접근 권한**을 세 가지 주체로 나눠서 관리한다.

1. **소유자 (User)**:
    - 파일을 만든 사용자로, 해당 파일에 대한 **읽기, 쓰기, 실행** 권한을 가질 수 있다.

2. **그룹 (Group)**:
    - 파일이 속한 그룹에 속한 사용자들로, 그룹에 속한 사용자들은 **읽기, 쓰기, 실행** 권한을 가질 수 있다.

3. **기타 사용자 (Other)**:
    - 소유자와 그룹에 속하지 않은 **모든 사용자들**. 이 사용자들에게는 보통 **읽기 권한**만 부여하거나, **접근을 차단**할 수 있다.

### 리눅스 파일 권한 관련 예시
리눅스에서 파일 권한을 설정하고 관리할 때, 각 주체에 따라 권한을 다르게 설정할 수 있다.

#### `chmod` 명령어를 사용하여 권한 변경
- 소유자에게 **읽기, 쓰기, 실행** 권한을 모두 부여하고, 그룹과 기타 사용자에게 **읽기 권한**만 부여하려면:
    ```bash
    chmod 744 filename
    ```
    - **7**: 소유자에게 **읽기(r)**, **쓰기(w)**, **실행(x)** 권한 모두 부여.
    - **4**: 그룹에게 **읽기 권한**만 부여.
    - **4**: 기타 사용자에게 **읽기 권한**만 부여.

<br/>
<br/>

## `umask`란?

**`umask`(User File Creation Mask)** 는 **리눅스**에서 새롭게 파일이나 디렉터리를 생성할 때의 **기본 권한을 설정**하는 데 사용되는 값이다. **파일의 기본 권한**에서 `umask` 값이 차감되어, 최종적인 파일 권한이 결정된다.

<br/>

### 1. `umask`의 역할

- **파일 생성 시 기본 권한을 설정**: 
  - 새 파일이나 디렉터리를 만들 때, `umask`에 설정된 값이 적용되어 기본 권한이 설정된다.
  - 기본적으로는 **보안상의 이유로 모든 권한이 허용되지 않고** 일부 권한이 차감되어 파일이 생성된다.

#### 기본 권한
- **파일의 기본 권한**: `666` (읽기 및 쓰기 권한, 실행 권한 없음)
- **디렉터리의 기본 권한**: `777` (읽기, 쓰기, 실행 권한 모두 허용)

**`umask`** 값은 기본 권한에서 **차감되는 권한**을 정의하며, 예를 들어 `umask 022`는 **쓰기 권한**을 그룹과 기타 사용자로부터 차감한다.

<br/>

### 2. `umask` 기본 동작

#### `umask` 값이 적용되는 방식
- **파일 생성 시 기본 권한 = 기본 권한 - umask 값**
- 예를 들어, 기본 파일 권한이 **666**이고 `umask` 값이 **022**라면:
  - 기본 권한 `666`에서 `022`를 차감 → 최종 권한 **644**
  - 즉, **소유자는 읽기/쓰기 권한**, **그룹과 기타 사용자는 읽기 권한만** 갖게 된다.

#### 디렉터리 생성 시
- 디렉터리는 기본적으로 **`777`** 권한을 가진다.
- 예를 들어, `umask`가 **002**라면:
  - 기본 디렉터리 권한 `777`에서 `002`를 차감 → 최종 권한 **775**
  - 즉, **소유자와 그룹은 읽기/쓰기/실행 권한**을, **기타 사용자는 읽기/실행 권한**을 갖는다.

<br/>

### 3. `umask` 값 확인 및 설정

#### 현재 `umask` 값 확인
```bash
$ umask
```
- 현재 설정된 umask 값을 확인할 수 있다. 일반적으로 002나 022로 설정되어 있다.

#### umask 값 설정

```bash
$ umask 022
```

- 022는 그룹과 기타 사용자에게 쓰기 권한을 주지 않는 설정을 의미한다.
- 002는 기타 사용자에게만 쓰기 권한을 제한하며, 그룹은 읽기/쓰기/실행 권한을 가진다.

<br/>

### **요약**
- `umask`는 새로 생성된 파일이나 디렉터리의 **기본 권한을 설정**하는 데 중요한 역할을 한다.
- 파일의 기본 권한에서 **`umask` 값을 차감**하여 최종 권한이 결정되며, 보안 및 시스템 관리에서 자주 사용된다.
- **`umask` 값을 확인하고 설정**함으로써, 새로 생성되는 파일에 대한 권한을 효율적으로 제어할 수 있다.

<br/>
<br/>

## `mactime`이란?

- `mactime` 은 리눅스/유닉스 환경에서 **파일 시스템의 타임스탬프 정보**를 분석하여 **파일의 생성 시간, 마지막 수정 시간, 마지막 접근 시간**을 타임라인 형식으로 보여주는 도구이다.
  특히, **디지털 포렌식**에서 시스템의 활동 내역을 분석하는 데 자주 사용된다.

<br/>

### 1. `mactime`에서 사용하는 타임스탬프 정보

`mactime` 도구는 **파일 시스템**에서 파일 및 디렉터리의 **세 가지 시간 정보**를 사용한다:

1. **M (Modification time, 수정 시간)**  
   - 파일이 마지막으로 **수정된 시간**을 나타낸다. 파일의 **내용**이 변경될 때 업데이트된다.

2. **A (Access time, 접근 시간)**  
   - 파일이 마지막으로 **읽히거나 접근된 시간**을 나타낸다. 파일을 읽거나 실행할 때 업데이트된다.

3. **C (Change time, 변경 시간)**  
   - 파일의 **메타데이터**(예: 권한, 소유자)가 마지막으로 **변경된 시간**을 나타낸다. 파일의 **속성**이 변경될 때 업데이트된다.

<br/>


### 2. `mactime` 사용 방법

`mactime`은 파일 시스템의 타임스탬프 정보를 수집하여, 그 정보를 바탕으로 **파일 시스템 활동의 타임라인**을 생성한다.

#### 예시: `mactime` 타임라인 생성
1. **타임라인 생성**
   - 파일 시스템에서 타임스탬프 정보를 수집하고 이를 이용해 타임라인을 생성한다.
   ```bash
   mactime -b bodyfile > timeline.txt
   ```

여기서 **bodyfile**은 타임스탬프 정보가 저장된 파일이며, **timeline.txt**는 생성된 타임라인 정보가 저장될 파일이다.

타임라인 분석
생성된 타임라인 파일은 파일 시스템의 파일 및 디렉터리가 언제 생성, 수정, 접근되었는지에 대한 정보를 제공한다.

<br/>

### 3. mactime의 활용 사례

mactime은 주로 디지털 포렌식 및 시스템 감사에서 사용되며, 파일 시스템의 활동 내역을 추적하는 데 유용하다.

1) 디지털 포렌식
해킹이나 보안 침해 사건에서, 파일이 언제 접근되었고 수정되었는지를 분석할 수 있다.
이를 통해 공격자의 활동 시간이나 변조된 파일을 추적할 수 있다.

3) 시스템 감사
시스템 관리자가 시스템에서 어떤 파일들이 수정되거나 접근되었는지 확인하고, 비정상적인 활동을 감지할 수 있다.

5) 보안 분석
시스템이 침해당한 시점과 공격자가 수정한 파일을 시간 순으로 추적하여 보안 위협을 분석하는 데 사용된다.

4. mactime의 필요성
파일 시스템에서 파일 활동 내역을 시간 순서대로 기록하여 분석하는 데 필수적인 도구이다.
보안 및 디지털 포렌식에서 파일의 생성, 수정, 접근 시간을 통해 비정상적인 활동을 파악하고 시스템 내 문제를 추적하는 데 도움이 된다.

6. mactime의 한계
mactime은 파일 시스템에서 제공하는 타임스탬프 정보만을 분석할 수 있으므로, 타임스탬프가 변경되거나 조작된 경우에는 분석의 정확도가 떨어질 수 있다.
따라서, 타임스탬프가 조작된 흔적이 있거나 파일이 삭제된 경우 추가적인 분석 도구와 함께 사용되어야 한다.

<br/>
<br/>


## mactime 명령어 사용 

### 1. `mactime` 사용 과정

#### Step 1: 파일 시스템에서 타임스탬프 정보 수집

먼저, **`fls`** 명령어를 사용해 **파일 시스템의 타임스탬프 정보**를 수집한다. 이 정보는 **bodyfile**이라는 파일로 저장된다.

```bash
fls -r /path/to/diskimage > bodyfile
```

- **`fls`**: 파일 시스템에서 파일 정보를 출력하는 도구
- **`-r`**: **재귀적으로** 모든 파일 및 디렉터리 정보를 가져옴
- **`/path/to/diskimage`**: 분석하고자 하는 디스크 이미지나 파일 시스템 경로
- **`bodyfile`**: 타임스탬프 정보가 저장되는 파일

<br/>

#### Step 2: `mactime`을 사용해 타임라인 생성

**`mactime`** 명령어를 사용하여 **bodyfile**에 저장된 타임스탬프 정보를 **타임라인**으로 변환

```bash
mactime -b bodyfile > timeline.txt
```

- **`-b`**: bodyfile을 사용하여 타임라인을 생성
- **`timeline.txt`**: 결과 타임라인이 저장될 파일

<br/>

### 2. `mactime` 결과 예시

**`timeline.txt`** 파일에 저장된 결과는 **파일 시스템의 타임스탬프 정보**가 시간순으로 정렬되어 표시됩니다. 각 파일의 **수정 시간(M)**, **접근 시간(A)**, **변경 시간(C)** 정보가 포함

#### 타임라인 결과 예시:

```plaintext
Date       Size     Type     Mode        UID   GID     Meta      File Name
-----------------------------------------------------------------------------------
2024-09-26 12:34:56 1024     r/rrwxrwxrwx   0     0     *INODE*   /path/to/file1.txt
2024-09-26 12:34:56 4096     d/drwxr-xr-x   1000  1000  *INODE*   /path/to/directory
2024-09-26 12:35:20 512      r/rrw-r--r--   1000  1000  *INODE*   /path/to/file2.log
2024-09-26 12:40:30 2048     r/rrw-r--r--   1000  1000  *INODE*   /path/to/file3.conf
```

<br/>

### 3. `mactime`의 실무 적용 예시

#### 시나리오:
디지털 포렌식에서 **침해 사고**가 발생하고 시스템의 **특정 파일**이 언제 수정되었고, 누가 접근했는지 조사해야 하는 상황일때, 시스템 관리자는 **`mactime`** 을 통해 파일 시스템의 **타임라인을 분석**하여 파일 활동을 추적할 수 있다.

#### 명령어 실행

```bash
fls -r /mnt/disk > bodyfile
mactime -b bodyfile > timeline.txt
```

#### 결과 

```plaintext
2024-09-26 12:34:56 1024     r/rrwxrwxrwx   0     0     *INODE*   /home/user/.bash_history
2024-09-26 12:40:20 2048     r/rrw-r--r--   1000  1000  *INODE*   /var/log/auth.log
2024-09-26 12:50:00 512      r/rrw-r--r--   1000  1000  *INODE*   /home/user/malicious_script.sh
```

- **`/home/user/.bash_history`**: **2024년 9월 26일 12:34:56**에 **수정됨**.
- **`/var/log/auth.log`**: **2024년 9월 26일 12:40:20**에 **접근됨**.
- **`/home/user/malicious_script.sh`**: **2024년 9월 26일 12:50:00**에 **수정됨**.

<br/>
<br/>


## 리눅스 파일 시스템 구조 설명


<img width="600" alt="image" src="https://github.com/user-attachments/assets/166b5d5a-d105-4ad0-a503-84e929ef9b7a">


### 주요 디렉터리 설명

<img width="400" alt="image" src="https://github.com/user-attachments/assets/9a21c8b8-6371-4628-b313-481265e1d053">

1. **`/` (루트 디렉터리)**:
   - 리눅스 파일 시스템의 최상위 디렉터리로, 모든 파일과 디렉터리가 이곳에 포함된다.
   
2. **`/bin`: 기본 명령어 실행 파일 저장소**:
   - 시스템 운영에 필요한 기본 명령어 실행 파일들이 저장된 곳. `ls`, `cp`, `mv`와 같은 필수 명령어가 여기에 위치한다.

3. **`/boot`: 부팅 관련 파일 저장소**:
   - 리눅스 커널과 부트로더 설정 파일이 저장된 곳으로, 시스템이 부팅될 때 이 파일들이 사용된다.

4. **`/dev`: 장치 파일 저장소**:
   - 시스템의 하드웨어 장치를 나타내는 파일들이 저장된 곳. 하드디스크, 터미널, 프린터와 같은 장치들이 파일로 표현된다.

5. **`/etc`: 설정 파일 저장소**:
   - 시스템과 서비스의 구성 파일들이 저장된 디렉터리. 네트워크 설정, 사용자 계정 정보, 시스템 서비스 설정 등이 여기에 저장된다.

6. **`/home`: 사용자 개인 파일 저장소**:
   - 각 사용자의 홈 디렉터리가 저장된 곳으로, 개인 파일과 설정들이 보관된다.

7. **`/lib`: 시스템 라이브러리 파일 저장소**:
   - 프로그램 실행에 필요한 공유 라이브러리 파일들이 위치한 곳이다.

8. **`/media` & `/mnt`: 외부 장치 마운트 포인트**:
   - 외부 장치(USB, CD-ROM)가 연결될 때 이곳에 마운트되어 접근할 수 있게 된다.

9. **`/opt`: 추가 소프트웨어 저장소**:
   - 선택적으로 설치한 애플리케이션이나 소프트웨어 패키지들이 저장된다.

10. **`/proc`: 실시간 시스템 정보 저장소**:
    - 커널과 프로세스 정보가 실시간으로 저장되는 가상 파일 시스템이다.

11. **`/root`: 루트 사용자의 홈 디렉터리**:
    - 루트 사용자의 개인 파일들이 저장된 디렉터리.

12. **`/sbin`: 시스템 관리 명령어 저장소**:
    - 시스템 관리자가 사용하는 시스템 관리 명령어들이 저장된 디렉터리.

13. **`/tmp`: 임시 파일 저장소**:
    - 프로그램들이 실행 중에 생성하는 임시 파일들이 저장된 곳으로, 재부팅 시 파일들이 삭제된다.

14. **`/usr`: 사용자 명령어와 애플리케이션 저장소**:
    - 시스템에서 사용되는 추가 애플리케이션과 명령어들이 여기에 저장된다. `/usr/bin`, `/usr/lib`, `/usr/share`와 같은 하위 디렉터리로 나뉜다.

15. **`/var`: 가변 데이터 저장소**:
    - 로그 파일, 이메일 큐, 프린터 대기열과 같은 자주 변경되는 데이터가 저장되는 디렉터리. 특히, 시스템 로그 파일이 `/var/log`에 저장된다.

<br/>
<br/>

## 리눅스 사용자 및 그룹 관리 파일과 명령어

- **`/etc/passwd`**, **`/etc/shadow`**, 그리고 **`/etc/group`** 은 리눅스 OS에서 **사용자 계정과 그룹 정보를 저장하고 관리**하는 파일들이다.
- 이 파일들은 리눅스의 **사용자 정보**, **그룹 정보**, **암호 설정**을 관리하는 **시스템 파일**들이다.

<br/>

### 1. 파일들의 역할

#### `/etc/passwd`: 사용자 계정 정보 저장 파일
- **사용자 계정에 대한 기본 정보**를 저장하는 파일.
- 사용자 이름, 사용자 ID(UID), 그룹 ID(GID), 홈 디렉터리, 로그인 셸 등의 정보가 기록된다.

#### `/etc/shadow`: 암호 정보 저장 파일
- 사용자 계정의 암호 정보를 저장하는 파일. 보안상의 이유로 암호화된 비밀번호와 암호 만료 정보가 포함되어 있으며, 이 파일은 **루트 사용자만 접근** 할 수 있다.

#### `/etc/group`: 그룹 정보 저장 파일
- 그룹 정보를 저장하는 파일. **그룹 이름**, **그룹 ID(GID)**, **그룹에 속한 사용자 목록**이 저장된다.

<br/>

### 2. 관련 명령어들

이 파일들을 직접 수정하는 대신, 다음 명령어들을 통해 **계정 관리**나 **그룹 관리** 작업을 수행할 수 있다.

#### **사용자 계정 관리 명령어**

- **`useradd`, `usermod`, `userdel`**: 사용자를 추가, 수정, 삭제하는 명령어들.
    - **예시**: 
      ```bash
      sudo useradd username  # 새로운 사용자 추가
      ```
      이 명령어를 실행하면 **/etc/passwd**와 **/etc/shadow**에 사용자 정보가 반영된다.

- **`passwd`**: 사용자의 비밀번호를 설정하거나 변경하는 명령어.
    - **예시**: 
      ```bash
      passwd username  # 사용자의 비밀번호 변경
      ```
      이 명령어는 **/etc/shadow** 파일에 비밀번호 정보를 저장한다.

#### **그룹 관리 명령어**

- **`groupadd`, `groupmod`, `groupdel`**: 그룹을 추가, 수정, 삭제하는 명령어들.
    - **예시**: 
      ```bash
      sudo groupadd groupname  # 새로운 그룹 추가
      ```
      이 명령어를 통해 **/etc/group** 에 그룹 정보가 반영된다.
      
<br/>
<br/>


## 리눅스 파일시스템 활용해보기: 같은 OS에서 사용자별 서버 실행 및 모니터링

- 리눅스 파일 시스템 개념을 알면 **같은 OS 안에서 각 사용자별로 독립적인 서버를 실행**하고, 이를 **모니터링**하거나 **자동화** 할 수 있다.
- 사용자마다 독립적인 **홈 디렉터리**와 **환경**을 가지므로, 각자의 서버를 실행하고 관리할 수 있기 때문이다.


### 1. 사용자별 서버 실행

각 사용자는 자신의 **홈 디렉터리**에서 **독립적인 서버**를 실행할 수 있다. 예를 들어, **Node.js**, **Python Flask**, **Django** 같은 서버를 사용자가 자신의 홈 디렉터리에서 실행하면 된다. 이를 통해 같은 OS 내에서 **다중 서버**를 운영할 수 있다.

#### 예시:
- **user1**이 5000번 포트에서 Flask 서버 실행:
  ```bash
  flask run --host=0.0.0.0 --port=5000
  ```
user2가 8000번 포트에서 Django 서버 실행:
```bash
python manage.py runserver 0.0.0.0:8000
```

### 2. 사용자별 서버 모니터링
각 사용자는 서버 상태를 모니터링할 수 있는 스크립트를 만들어, 자신의 유저 bin 디렉터리에 저장한 후, 이를 주기적으로 실행하도록 설정할 수 있다. 이를 통해 CPU 사용량, 메모리 사용량 등을 체크하여 서버 상태를 모니터링할 수 있다.

예시: user1의 서버 모니터링 스크립트
```python
# ~/bin/server_monitor.py
import psutil

def monitor_server():
    cpu = psutil.cpu_percent(interval=1)
    memory = psutil.virtual_memory().percent
    print(f"Server CPU usage: {cpu}%, Memory usage: {memory}%")

if __name__ == "__main__":
    monitor_server()
```

**cron**을 이용해 주기적으로 실행:

```bash
crontab -e
# 5분마다 서버 상태 모니터링
*/5 * * * * ~/bin/server_monitor.py >> ~/monitor.log
```

### 3. 사용자별 로그 관리
각 사용자는 자신의 로그 파일을 관리할 수 있다. 예를 들어, /home/user1/logs 디렉터리에 로그 파일을 저장하고, 이를 통해 서버의 동작 상태를 확인할 수 있다. 이를 통해 오류 발생 시 로그 분석도 가능하다.

### 4. 포트 관리
사용자별 서버를 다른 포트에서 실행하면, 같은 OS에서도 여러 개의 서버를 충돌 없이 동시에 실행할 수 있다. 예를 들어, user1은 5000번 포트에서 서버를 실행하고, user2는 8000번 포트에서 실행할 수 있다.

### 5. 현업에서의 활용
이러한 구조는 특히 다중 사용자 서버 환경이나 개발팀에서 공유 서버를 사용할 때 매우 유용하다. 각 개발자가 같은 서버를 사용하면서도 독립적인 테스트 서버나 개발 환경을 운영할 수 있기 때문이다.

- 개발팀이 같은 서버를 공유하되, 사용자별로 독립적인 환경을 유지할 수 있다.
- 서버 자원을 공유하면서도, 각 사용자가 자신의 서버를 독립적으로 모니터링하고 관리할 수 있다.
- 로그 파일 분석이나 서버 상태 모니터링 작업을 개별적으로 자동화할 수 있다.


<br/>
<br/>

## 리눅스 특수 권한: setuid, setgid, sticky bit

| 특수 권한  | 역할                                                                                             | 네이밍 의미                                                      | 설정 방법             | 확인 방법               |
|------------|--------------------------------------------------------------------------------------------------|------------------------------------------------------------------|-----------------------|-------------------------|
| **setuid** | 파일이 실행될 때 **파일 소유자의 권한**으로 실행되도록 함.                                         | **Set User ID**: 실행 시 소유자의 사용자 ID로 실행됨.            | `chmod u+s filename`  | `ls -l`에서 **s** 표시   |
| **setgid** | - **파일**: 파일이 **소유 그룹의 권한**으로 실행됨. <br> - **디렉터리**: 생성된 파일이 **부모 디렉터리의 그룹**을 상속받음. | **Set Group ID**: 실행 시 소유 그룹 ID로 실행되거나 상속됨.     | `chmod g+s directory` | `ls -l`에서 **s** 표시   |
| **Sticky Bit** | 디렉터리 내에서 **파일 소유자만 그 파일을 삭제**할 수 있게 제한함.                               | **Sticky**: 파일을 디렉터리에 고정시켜 소유자 외에 삭제 불가.   | `chmod +t directory`  | `ls -l`에서 **t** 표시   |


- 리눅스에서 **특수 권한**은 **setuid**, **setgid**, **sticky bit**로 구성어 있다.
- 이 권한들은 특정한 상황에서 파일이나 디렉터리에 대한 **보안** 및 **접근 제어**를 강화하는 데 사용된다.

<br/>

### 1. setuid (Set User ID)

- **setuid**는 파일에 적용되는 특수 권한으로, 파일이 실행될 때 해당 파일의 **소유자 권한**으로 실행되도록 한다.
- 일반적으로 **root 사용자**가 소유한 프로그램이 **setuid**로 설정되면, 해당 프로그램을 실행하는 모든 사용자는 **root 권한**으로 실행할 수 있다.

#### 사용 예시:
- **passwd** 명령어는 **setuid**가 설정된 프로그램으로, 일반 사용자도 **root 권한**을 임시로 획득하여 자신의 비밀번호를 변경할 수 있다.

#### setuid 설정 방법:
```bash
chmod u+s filename
```

#### setuid 확인:
파일의 권한을 확인하면, 실행 권한 부분에 **s**가 표시된다.
```bash
ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 421K Sep  26 14:00 /usr/bin/passwd
```

<br/>

### 2. setgid (Set Group ID)
setgid는 파일 또는 디렉터리에 적용되며, 파일의 경우 그 파일이 실행될 때 해당 파일이 속한 그룹 권한으로 실행된다. 디렉터리의 경우, 해당 디렉터리 내에서 생성되는 모든 파일이나 디렉터리는 부모 디렉터리의 그룹 소유권을 상속받는다.

#### 사용 예시:
- 공유 디렉터리에서 사용되며, 디렉터리 내에서 생성된 파일들이 자동으로 동일한 그룹을 가지도록 설정할 수 있다.
setgid 설정 방법:
```bash
chmod g+s directory_name
```
setgid 확인:
파일이나 디렉터리의 권한에서 **s**가 표시된다.

```bash
ls -l directory_name
drwxr-sr-x 2 user group 4096 Sep  26 14:00 directory_name
```

<br/>

### 3. Sticky Bit (스티키 비트)
Sticky Bit는 디렉터리에 적용되며, 디렉터리의 모든 사용자가 파일을 생성하거나 수정할 수 있지만, 자신이 소유한 파일만 삭제할 수 있도록 제한하는 특수 권한이다. 주로 공유 디렉터리에서 다른 사용자가 실수로 파일을 삭제하지 못하도록 설정할 때 사용된다.

#### 사용 예시:
/tmp 디렉터리는 sticky bit가 설정되어 있어, 모든 사용자가 파일을 생성할 수 있지만, 자신이 소유한 파일만 삭제할 수 있다.
sticky bit 설정 방법:

```bash
chmod +t directory_name
```
sticky bit 확인:
디렉터리의 권한에서 **t**가 표시된다.
```bash
ls -l /tmp
drwxrwxrwt 10 root root 4096 Sep 26 14:00 /tmp
```

<br/>

### 4. 주의할 점

- 리눅스에서 **특수 권한 설정**은 파일 자체의 내용을 변경하는 것이 아니라, **파일 시스템의 권한 정보**를 조작하여 **누가 해당 파일이나 디렉터리에 접근할 수 있는지**를 결정하는 과정이다.
- 이를 비유하자면, 파일은 **방 안의 물건**이고, 권한 설정은 그 방에 걸린 **자물쇠**라고 할 수 있다. **chmod**와 같은 명령어는 이 자물쇠를 설정하거나 변경하여, 특정 사용자나 그룹이 그 방을 열 수 있는 **열쇠**를 부여하는 것과 같다.
- **setuid**는 파일을 실행하는 사용자가 **파일 소유자의 권한**으로 실행되게 하여 **주인의 열쇠**로 문을 여는 것이고, **setgid**는 **그룹의 열쇠**로 문을 열 수 있도록 설정하는 것이다.
**sticky bit**는 공유된 디렉터리에서 **각자 자신의 파일만 삭제**할 수 있도록 **자물쇠를 설정하는 것**과 같은 역할을 한다.
  이러한 권한 설정을 통해 리눅스는 **사용자와 그룹 간의 권한 관리**를 유연하게 할 수 있게 된다.

### 5. 정리(uid 와 gid)
- **UID(User ID)** 와 **GID(Group ID)** 는 각각 **사용자**와 **그룹**을 식별하는 번호로, 리눅스 시스템에서 **파일과 디렉터리에 대한 소유권**을 결정하는 역할을 수행한다.
- **UID**는 특정 파일이나 디렉터리의 **소유자를 식별**하고, **GID**는 그 파일이나 디렉터리가 속한 **그룹**을 식별한다.
- 이를 통해 리눅스는 파일과 디렉터리에 대한 **소유자와 그룹의 접근 권한**을 관리하며, **setuid**, **setgid**, **sticky bit** 같은 특수 권한을 적용하여 파일 시스템의 **보안과 협업** 관련 설정을 컨트롤한다.


<br/>
<br/>

## 리눅스의 전체 구조와 Shell, Bash의 역할

- 리눅스 시스템은 하드웨어와 사용자 사이에서 여러 계층이 존재하며, 각각의 계층은 특정한 역할을 담당하고 있다.
- 그중에서도 **Shell**과 **Bash**는 **사용자와 리눅스 커널** 사이에서 중요한 역할을 하며, 시스템과의 상호작용을 도와준다.
- 아래는 리눅스 시스템의 전체 구조와 그 속에서 **Shell**과 **Bash**가 어디에 위치하는지 설명한 내용이다.

<br/>

## 리눅스 시스템의 전체 구조

```plaintext
사용자
  |
  v
응용 프로그램 / 명령어
  |
  v
Shell (Bash)
  |
  v
리눅스 커널 (Kernel)
  |
  v
하드웨어 (Hardware)
```


1. **하드웨어 (Hardware)**:
   - **컴퓨터의 물리적 장치**로, CPU, 메모리, 디스크, 네트워크 카드와 같은 실제 장비들이다.
   - 이 하드웨어는 직접적으로 **사용자**나 **소프트웨어**와 소통할 수 없고, 커널이 이 자원들을 제어한다.

2. **리눅스 커널 (Linux Kernel)**:
   - **리눅스 운영체제의 핵심**으로, 하드웨어 자원을 관리하고 소프트웨어와 하드웨어 사이에서 **중재자 역할**을 한다.
   - 커널은 **프로세스 관리**, **메모리 관리**, **파일 시스템 관리**, **네트워크 관리** 등을 담당하며, 시스템 전체의 자원을 조정하고 보호한다.
   - 모든 명령어는 **커널**을 통해 **하드웨어** 자원에 접근한다.

3. **셸 (Shell)**:
   - **셸**은 **사용자와 커널 사이의 인터페이스** 역할을 한다. **명령어를 입력받아 해석**한 후, 이를 **커널에게 전달**한다.
   - 셸은 여러 종류가 있으며, 사용자가 터미널에서 명령어를 입력하면 셸이 그 명령을 처리하고 커널에게 요청을 보낸다.
   - **Bash**, **Zsh**, **Csh** 등 다양한 셸이 있지만, **Bash**는 리눅스에서 가장 많이 사용되는 기본 셸이다.

4. **Bash (Bourne Again Shell)**:
   - **Bash**는 가장 널리 사용되는 **리눅스 셸**로, 사용자가 명령어를 입력하고 시스템과 상호작용할 수 있는 **텍스트 기반의 인터페이스**를 제공한다.
   - **Bash**는 명령어 해석뿐만 아니라 **스크립트 언어**로도 사용되며, **자동화 작업**을 쉽게 처리할 수 있다.
   - 사용자와 커널 사이의 **중간 다리 역할**을 하며, 커널에 명령어를 전달하고 실행 결과를 사용자에게 보여준다.

5. **응용 프로그램 (Application)**:
   - 응용 프로그램은 **셸**을 통해 실행될 수 있지만, **커널의 시스템 호출**을 통해 직접 커널과 상호작용할 수도 있다.
   - 터미널을 통해 명령어 기반으로 작동하는 프로그램 외에도 **그래픽 애플리케이션**은 **GUI** 환경에서 동작하며, 커널과의 직접적인 통신을 한다.
  
<br/>
<br/>

## Makefile이 Shell(Bash)로 작성되어 자동화되는 원리

- 예전 플러터 팀프로젝트할 때 팀원 한 분이 셸명령어로 작성된 makefile로 자동화시키는 것을 본적이 있다. 마침 리눅스-셸 공부한 김에 이부분에 대해서도 살펴보았다.
- 먼저 **Makefile**은 **Bash 명령어**와 같은 **셸 명령어**로 작성되어 **프로젝트의 빌드 및 자동화 작업**을 처리하는 파일이다.
- 터미널에서 `make` 명령어를 사용해 Makefile을 실행하면, **셸(Shell)**과 **커널(Kernel)**이 상호작용하여 자동으로 작업이 처리된다.

### Makefile의 자동화 동작 원리

#### 1. **셸(Shell)이 명령어를 해석한다**
- **Makefile**은 주로 **프로젝트의 루트 디렉터리**에 위치하며, 그 안에 정의된 **Bash 명령어**는 `make` 명령을 통해 실행된다.
- 사용자가 터미널에서 `make` 명령어를 입력하면, **Bash**와 같은 **셸**이 이를 해석하고 Makefile의 내용을 처리하기 시작한다.

#### 2. **셸이 커널에 요청을 보낸다**
- 셸이 **Makefile의 명령어**를 해석한 후, 각 명령어는 **시스템 호출(System Call)**을 통해 **커널(Kernel)**에 전달된다.
- 예를 들어, `gcc` 명령어를 통해 파일을 컴파일하려면, 셸은 **컴파일 요청**을 커널에 보내고, 커널은 이를 처리하기 위해 **프로세스를 생성**하고 **파일 시스템에 접근**한다.

#### 3. **커널이 하드웨어와 소통한다**
- **커널**은 셸로부터 받은 명령을 실행하기 위해 **하드웨어 자원**을 제어한다. 커널은 파일을 메모리에 로드하거나, CPU를 사용해 컴파일 작업을 실행하는 등 실제로 하드웨어와 소통하는 역할을 한다.
- 커널은 **파일 시스템, 메모리, CPU** 등의 자원을 관리하여 요청된 작업을 처리한다.

#### 4. **결과를 사용자에게 전달**
- 커널이 명령을 처리한 후, 그 결과를 **셸에 전달**하고, 셸은 그 결과를 다시 **터미널에 출력**한다.
- 예를 들어, 파일이 정상적으로 컴파일되었는지 여부나 오류 메시지가 터미널에 표시된다.

<br/>

### 셸과 커널의 상호작용 흐름

```plaintext
1. 사용자가 `make` 명령을 입력
       |
2. 셸(Shell)이 Makefile의 명령어를 해석
       |
3. 셸이 해석한 명령을 커널(Kernel)에 전달 (시스템 호출)
       |
4. 커널이 명령을 수행하고 하드웨어 자원을 제어 (파일 컴파일, 프로세스 실행 등)
       |
5. 작업이 완료되면 커널이 결과를 셸에 전달
       |
6. 셸이 결과를 터미널에 출력하여 사용자에게 보여줌
```

<br/>

### 활용예제: Flutter 프로젝트에서 Makefile 사용

- Flutter는 여러 가지 명령어를 통해 앱을 빌드하고 실행할 수 있다. 이러한 명령어들을 Makefile에 정의해 두면, 간단한 명령어로 여러 작업을 자동화할 수 있다.

#### **Makefile 예시**

```makefile
# Flutter Makefile

# 기본 타깃
all: clean get build

# Flutter 명령어를 정의
clean:
	flutter clean

get:
	flutter pub get

build:
	flutter build apk --release

# 추가적인 명령어들
run:
	flutter run

test:
	flutter test
```
Makefile을 프로젝트 루트에 두고, 간단하게 make 명령어로 자동화
```bash
# 명령어
make           # clean, get, build가 순차적으로 실행됨
make run       # Flutter 앱이 실행됨
make test      # 테스트가 실행됨
```

### Makefile 설명
- `all`: make 명령어를 실행하면 clean, get, build를 차례로 실행한다.
- `clean`: flutter clean 명령어를 통해 프로젝트의 불필요한 파일을 정리.
- `get`: flutter pub get을 통해 필요한 패키지들을 다운로드.
- `build`: flutter build apk --release를 사용하여 Release APK 파일을 빌드.
- `run`: make run 명령어로 Flutter 앱을 실행.
- `test`: make test 명령어로 테스트를 실행.

<br/>
<br/>


## 리눅스에서의 사용자 정보 및 비밀번호 관리

- 리눅스 시스템에서는 사용자 정보와 비밀번호를 특정 시스템 파일을 통해 관리하며, 이 파일들은 `/etc` 디렉토리 안에 위치한다. 아래는 각 파일의 역할과 관련 명령어들을 정리한 내용이다.

### 1. 사용자 정보 파일: `/etc/passwd`
`/etc/passwd` 파일은 리눅스 시스템의 모든 사용자 계정 정보를 담고 있다. 이 파일은 **텍스트 형식**으로 저장되며, 시스템 내 모든 사용자가 읽을 수 있다.

#### `/etc/passwd` 파일의 형식
각 사용자는 한 줄로 표현되며, 아래와 같은 필드들로 구성된다
```
username:x:UID:GID:comment:home_directory
```

- **username**: 사용자 이름
- **x**: 비밀번호는 `/etc/shadow` 파일에 저장되므로 이 자리는 `x`로 표시
- **UID**: 사용자 ID (User ID)
- **GID**: 기본 그룹 ID (Group ID)
- **comment**: 사용자 설명 (예: 사용자 이름 등)
- **home_directory**: 사용자 홈 디렉토리 경로
- **shell**: 사용자 로그인 시 기본으로 사용할 셸

#### 예시
```bash
john:x:1001:1001
Doe:/home/john:/bin/bash
```

### 2. 비밀번호 및 보안 정보 파일: `/etc/shadow`
`/etc/shadow` 파일은 **암호화된 비밀번호**와 함께 사용자 계정의 **비밀번호 만료 정보**를 저장한다. 이 파일은 보안상의 이유로 루트 사용자만 접근할 수 있다.

#### `/etc/shadow` 파일의 형식
각 사용자는 한 줄로 표현되며, 다음과 같은 필드로 구성된다

```bash
username:password:last_change:min:max:warn:inactive
```

- **username**: 사용자 이름
- **password**: 암호화된 비밀번호
- **last_change**: 마지막으로 비밀번호가 변경된 날짜 (유닉스 시간 기준)
- **min**: 최소 비밀번호 변경 주기 (일 단위)
- **max**: 최대 비밀번호 유효 기간 (일 단위)
- **warn**: 비밀번호 만료 전 경고할 일수
- **inactive**: 비밀번호 만료 후 계정 비활성화 기간
- **expire**: 계정 만료 날짜 (유닉스 시간 기준)

#### 예시

```bash
john:$6$random_salt$encrypted_password:18765:0:99999:7:::
```

### 3. 그룹 정보 파일: `/etc/group`
`/etc/group` 파일은 **그룹 정보**를 저장하며, 각 그룹에 속한 사용자 목록도 포함된다.

#### `/etc/group` 파일의 형식

- **group_name**: 그룹 이름
- **password**: 그룹 비밀번호 (거의 사용되지 않음, 일반적으로 `x`)
- **GID**: 그룹 ID
- **user_list**: 그룹에 속한 사용자 목록 (쉼표로 구분)

#### 예시

```bash
developers:x:1002
,jane
```

### 4. 관련 명령어들
#### 사용자 계정 관리
- `useradd`, `usermod`, `userdel`: 사용자 추가, 수정, 삭제 명령어
  ```bash
  sudo useradd new_user
  sudo usermod -aG group_name user_name
  sudo userdel user_name
  ```
- passwd: 사용자의 비밀번호 변경 및 설정 명령어

    ```bash
    passwd user_name
    ```

- 비밀번호 만료 관리
chage: 사용자의 비밀번호 만료 및 계정 비활성화 설정

    ```bash
    sudo chage -l user_name  # 사용자 비밀번호 만료 정보 확인
    sudo chage -M 90 user_name  # 비밀번호 최대 사용 기간 설정 (90일)
    ```

### 5. 리눅스의 사용자 정보 관리 구조
- 리눅스에서는 사용자 계정과 비밀번호 정보를 파일로 관리하며, 이를 통해 시스템은 로그인 및 권한 관리를 수행한다.
- 이 정보는 루트 권한이 있어야 수정할 수 있으며, 보안이 중요한 시스템에서는 /etc/shadow 파일을 통해 비밀번호가 암호화된 상태로 저장된다.

### 정리
- /etc 디렉토리에 있는 파일들은 마치 시스템의 전화번호부와 같다. 여기에는 모든 사용자 계정의 정보, 비밀번호, 그룹에 대한 기록이 저장된다.
- /home 디렉토리는 각 사용자의 개인 사무실이다. 이 사무실은 전화번호부에 기록된 사용자 정보(예: 주소와 소속)에 따라 자동으로 배정되고, 사용자는 본인만이 이 사무실을 사용할 수 있다.



<br/>
<br/>

## 리눅스 사용자 관리 방식과 JWT 토큰의 유사성

- 최근 JWT 구축을 했다보니 리눅스 사용자 관리방식이 JWT토큰과 유사하다는 인상을 받았다.
- 리눅스의 유저관리 방법에 대한 이해를 높이기 위해 비교를 해보았다.

### 1. 리눅스와 JWT의 유사성 비교

| 리눅스 사용자 관리 | JWT 토큰 기반 사용자 관리 |
|-----------------|-------------------------|
| **/etc/passwd, /etc/shadow, /etc/group**와 같은 시스템 파일에 사용자의 정보를 저장하고 관리함. | **JWT 토큰**에 사용자의 인증 정보(예: 사용자 ID, 권한 등)를 인코딩하여 저장함. |
| 파일 기반으로 **사용자 계정, 비밀번호, 그룹 정보**를 관리하고, 각 계정이 로그인할 때 시스템이 해당 정보를 확인함. | 서버는 사용자가 로그인할 때 **JWT 토큰**을 발급하여, 이후 요청 시 해당 토큰을 확인함. |
| **UID와 GID**를 통해 사용자의 **접근 권한**을 관리하고, 파일 시스템 내의 특정 리소스에 대한 접근을 제어함. | **JWT 페이로드**에 사용자 **권한 정보(roles)** 를 포함시켜, 인증된 사용자만 특정 리소스에 접근할 수 있도록 제어함. |
| 사용자가 로그인하거나 파일에 접근할 때마다, 시스템은 **/etc/shadow** 파일을 통해 비밀번호를 확인하고 권한을 체크함. | 클라이언트가 서버에 요청할 때마다 **JWT 토큰**을 전달하고, 서버는 이 토큰을 검증하여 유효한지 확인한 뒤 권한을 체크함. |

(**/etc/shadow**는 리눅스에서 사용자 계정의 암호 정보를 저장하는 파일이다. 이 파일에는 암호화된 비밀번호와 함께 암호 만료 날짜, 계정 만료 정보 등이 포함되어 있다.)

### 2. 비유적인 설명

- **리눅스의 사용자 관리 방식**은 회사가 모든 직원의 정보를 **사무실 문서함**에 기록해 두고, 직원이 회사 리소스에 접근할 때마다 해당 문서함에서 정보를 꺼내와 확인하는 방식이다. 이 문서함에는 직원의 권한과 역할도 기록되어 있어, 직원이 사용할 수 있는 리소스를 구분할 수 있다.

- **JWT 토큰**은 회사가 직원에게 발급하는 **임시 ID 카드**와 같다. 이 카드는 직원의 정보와 권한이 인코딩되어 있으며, 직원이 회사 내에서 리소스에 접근할 때마다 이 카드를 보여주면 권한을 확인할 수 있다. 이 카드는 일정 시간이 지나면 만료되며, 만료된 경우 다시 로그인해 새 카드를 발급받아야 한다.

### 3. 차이점

1. **저장 방식**:
   - 리눅스는 **서버 내의 파일 시스템**에 사용자 정보를 저장하고 관리한다.
   - JWT는 **토큰을 클라이언트 측에 저장**하고, 서버에 대한 요청 시마다 토큰을 전송한다.

2. **상태 관리**:
   - 리눅스는 **상태 기반** 관리 방식으로, 시스템 파일에 지속적으로 사용자 정보가 남아 있다.
   - JWT는 **무상태(stateless)** 방식으로, 서버가 사용자 세션을 유지할 필요 없이 토큰만으로 인증을 처리한다.



