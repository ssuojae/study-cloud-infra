## 목차

1. [Virtual Machine 와 Docker 비교](#virtual-machine-와-docker-비교)
2. [Virtual Machine 와 Container 비교](#virtual-machine-와-container-비교)
3. [BIOS와 UEFI, 그리고 파티션](bios와-uefi,-그리고-파티션)
4. [원격 연결에서의 네트워크 계층 이해](원격-연결에서의-네트워크-계층-이해)
5. [NAT가 4계층에서 동작하는 방식](nat가-4계층에서-동작하는-방식)
6. [리눅스 파일 시스템 구조와 inode](리눅스-파일-시스템-구조와-inode)

<br/>
<br/>

## Virtual Machine 와 Docker 비교

<image src="https://github.com/user-attachments/assets/21596f0c-d7fa-4fd6-a049-b9a30f449c65" width="300">

<img src="https://github.com/user-attachments/assets/fc44a46f-77da-40db-85c0-ab78dd55f4cf" width="300">

- 공부하면서 궁금해졌다. 이렇게 복잡하게 VMI를 나눠서 가상화하느니 그냥 도커로 분리된 환경에서 작업하면되는거 아닌가..? VM과 도커가 어떤차이가 있지?
- 

<br/>
<br/>

## Virtual Machine 와 Container 비교


<br/>
<br/>


## BIOS와 UEFI, 그리고 파티션

### 1. BIOS와 UEFI의 차이

BIOS(Basic Input/Output System)와 UEFI(Unified Extensible Firmware Interface)는 컴퓨터의 부팅 과정에서 가장 먼저 실행되는 펌웨어로, 하드웨어 초기화와 운영체제 로드를 담당한다.

#### BIOS
- **역할**: 전통적인 펌웨어로, 하드웨어 초기화 후 운영체제를 로드한다.
- **파티션 방식**: **MBR(Master Boot Record)** 방식으로 파티션을 관리한다.
- **제한 사항**:
  - 최대 **4개의 기본 파티션**만 지원하며, 2TB 이상의 디스크는 지원하지 않는다.
  - 부팅 속도가 상대적으로 느리다.
  
#### UEFI
- **역할**: BIOS를 대체하는 현대적인 펌웨어로, 더 빠른 부팅 속도와 다양한 기능을 제공한다.
- **파티션 방식**: **GPT(GUID Partition Table)** 방식으로 파티션을 관리한다.
- **장점**:
  - **128개 이상의 파티션**을 만들 수 있으며, 이론적으로 **9.4ZB(제타바이트)** 크기의 디스크까지 지원한다.
  - **Secure Boot**를 통해 신뢰할 수 없는 운영체제나 소프트웨어가 실행되지 않도록 보호한다.
  - 부팅 속도가 빠르고, 그래픽 인터페이스와 마우스 지원을 제공한다.

### 2. MBR과 GPT 파티션 구조

#### MBR (Master Boot Record)
- 디스크의 첫 번째 섹터에 부트 로더와 파티션 정보를 저장하는 방식이다.
- **제한 사항**:
  - 최대 **4개의 기본 파티션**만 지원하며, 확장 파티션을 통해 추가적인 논리 파티션을 만들어야 한다.
  - 2TB 이상의 디스크는 지원하지 않는다.

#### GPT (GUID Partition Table)
- MBR의 한계를 극복한 방식으로, 디스크의 첫 번째 섹터뿐만 아니라 마지막 섹터에도 파티션 테이블의 복사본을 저장한다.
- **장점**:
  - **128개 이상의 파티션**을 만들 수 있으며, **9.4ZB**까지의 대용량 디스크를 지원한다.
  - 파티션 테이블의 복사본을 저장해 파티션 손상 시에도 복구가 가능하다.

### 3. 파티션이란?

- 파티션은 하나의 물리적 디스크를 여러 개의 독립된 공간으로 나누는 것을 의미한다. 각각의 파티션은 운영체제가 다른 하나의 독립된 드라이브처럼 취급되며, 운영체제와 데이터를 별도로 관리할 수 있는 장점을 제공한다.
- **디스크**를 하나의 큰 집이라고 생각하고, **파티션**은 그 집 안에 있는 여러 개의 방이다. 각 방은 독립적으로 사용되며, 방 하나에 문제가 생기더라도 다른 방에는 영향을 미치지 않는다.
- 예를 들어, 한 방에는 운영체제를 설치하고, 다른 방에는 중요한 데이터를 저장할 수 있다. 이렇게 하면 운영체제에 문제가 생겨도 데이터는 보호된다.

### 4. BIOS와 UEFI에서의 파티셔닝

- **BIOS**는 **MBR** 파티션 방식을 사용하여 최대 4개의 파티션만 만들 수 있으며, 2TB 이상의 디스크를 지원하지 않는다.
- **UEFI**는 **GPT** 파티션 방식을 사용하여 128개 이상의 파티션을 만들 수 있으며, 이론적으로 9.4ZB까지의 디스크를 지원한다.
- GPT는 파티션 테이블의 복사본을 저장하고 복구 기능을 제공하는 등 안전성도 높다. 이러한 이유로 최근에는 UEFI와 GPT가 더 많이 사용된다.

<br/>
<br/>

## 원격 연결에서의 네트워크 계층 이해

#### 1. 애플리케이션 계층 (Application Layer)
- **SSH**와 **RDP**는 애플리케이션 계층에서 동작하는 **원격 접속 프로토콜**이다.
- **SSH**: 터미널 기반의 원격 접속을 가능하게 해주는 프로토콜로, 주로 **TCP 포트 22**를 사용한다.
- **RDP**: GUI 기반의 원격 접속을 가능하게 해주는 프로토콜로, **TCP 포트 3389**를 사용한다.
- 사용자는 애플리케이션 계층에서 SSH 클라이언트나 RDP 클라이언트를 사용해 가상 머신의 IP 주소로 원격 접속을 시도한다.

#### 2. 전송 계층 (Transport Layer)
- **전송 계층**에서는 **TCP**를 사용해 **신뢰성 있는 데이터 전송**을 보장한다.
- **TCP**는 애플리케이션 계층에서 전달된 데이터를 패킷으로 나누고, 이를 손실 없이 전송한다.
- 원격 연결 시 사용되는 포트:
  - **SSH**: TCP 포트 22
  - **RDP**: TCP 포트 3389
- 전송 계층은 데이터를 안정적으로 주고받는 역할을 한다.

#### 3. 인터넷 계층 (Network Layer)
- **인터넷 계층**은 **IP 주소를 기반**으로 데이터 패킷을 **올바른 경로**로 전달하는 역할을 한다.
- 브리지 모드에서 가상 머신은 로컬 네트워크에서 **독립적인 IP 주소**를 할당받는다.
- 가상 머신의 IP 주소를 통해 네트워크 상의 위치를 결정하고, 해당 IP를 사용해 원격 연결이 이루어진다.

#### 4. 네트워크 인터페이스 계층 (Network Interface Layer)
- **네트워크 인터페이스 계층**에서는 **MAC 주소**를 통해 **이더넷 프레임**을 생성하고, 실제 네트워크 인터페이스(이더넷, Wi-Fi 등)를 통해 데이터가 전송된다.
- 실제 물리적 네트워크 상에서 데이터 전송이 이루어지는 단계로, **호스트 컴퓨터와 가상 머신 간의 물리적 연결**이 이 계층에서 처리된다.

### 정리: 여러 계층의 상호작용
- **애플리케이션 계층**: SSH와 RDP와 같은 원격 접속 프로토콜이 사용자와 상호작용하는 계층.
- **전송 계층**: TCP 프로토콜을 사용해 신뢰성 있는 데이터 전송을 보장.
- **인터넷 계층(네트워크 계층)**: IP 주소 기반으로 데이터의 경로를 설정하고 전송.
- **네트워크 인터페이스 계층**: 실제 물리적 네트워크 인터페이스에서 데이터 전송이 이루어짐.

<br/>
<br/>

## NAT가 4계층에서 동작하는 방식

- NAT(Network Address Translation)는 주로 **네트워크 계층(인터넷 계층)** 에서 동작하지만, **전송 계층(Transport Layer)** 과도 깊은 연관이 있다.
- NAT는 IP 주소와 포트 번호를 변환하는 과정에서 네트워크와 전송 계층 모두에서 기능하며, 네트워크 통신을 효율적으로 처리한다.

<br/>

### 1. **애플리케이션 계층 (Application Layer)**
- NAT는 애플리케이션 계층에서 직접 동작하지 않는다. 하지만, 애플리케이션 계층의 **SSH, RDP**와 같은 원격 접속 서비스가 사용하는 데이터가 전송 계층과 네트워크 계층을 통해 NAT에 의해 변환된다.
- 애플리케이션은 사용자가 요청한 데이터를 패킷으로 전송하기 위해 **IP 주소**와 **포트 번호**를 사용하며, 이 정보가 NAT에 의해 변환된다.


### 2. **전송 계층 (Transport Layer)**
- **전송 계층**에서는 **TCP**와 **UDP** 프로토콜을 사용해 **포트 번호**를 관리하고, 애플리케이션 간의 데이터 전송을 책임진다.
- NAT는 전송 계층에서 **포트 번호**를 변환하여, 여러 장치가 하나의 공인 IP 주소를 공유하면서도 서로 다른 서비스에 접근할 수 있도록 한다. 이 과정을 **NAPT(Network Address Port Translation)** 또는 **포트 포워딩**이라고 부른다.

#### 전송 계층에서 NAT가 동작하는 방식:
- **포트 번호 변환**: 내부 네트워크에서 각각의 가상 머신이나 장치가 다른 포트 번호를 사용하고, NAT는 외부에서 들어오는 트래픽이 올바른 내부 장치로 도달하도록 포트 번호를 변환한다.
  - 예시: 외부에서 `호스트_IP:2222`로 들어오는 트래픽을 NAT가 가상 머신의 `192.168.1.100:22`로 포워딩한다.
- **TCP/UDP 패킷 처리**: NAT는 **TCP**와 **UDP** 트래픽의 **소스 포트**와 **목적지 포트**를 변환하여 각 패킷이 적절한 내부 네트워크 장치에 도달하게 한다.


### 3. **인터넷 계층 (Network Layer)**
- **네트워크 계층**에서는 데이터 패킷의 **IP 주소**를 처리하며, NAT는 이 계층에서 **IP 주소 변환**을 수행한다.
- 내부 네트워크의 장치들은 **사설 IP 주소**를 사용하고, NAT는 이를 **공인 IP 주소**로 변환하여 외부 네트워크와 통신할 수 있게 한다.

#### 네트워크 계층에서 NAT가 동작하는 방식:
- **IP 주소 변환**: NAT는 **사설 IP**와 **공인 IP** 간의 변환을 통해 내부 네트워크에서 외부 네트워크로 나가는 트래픽을 처리한다.
  - 예시: 가상 머신의 IP 주소 `192.168.1.100`을 외부 네트워크에 보낼 때, NAT가 이를 호스트의 공인 IP 주소로 변환한다.
- **경로 설정**: NAT는 패킷이 외부 네트워크로 나가거나 내부 네트워크로 들어올 때 적절한 IP 주소로 변환해 경로를 설정한다.


### 4. **네트워크 인터페이스 계층 (Network Interface Layer)**
- **네트워크 인터페이스 계층**에서는 데이터가 물리적 네트워크를 통해 전송된다. 여기서 NAT는 **MAC 주소**나 **프레임 전송**에는 영향을 주지 않지만, 네트워크 인터페이스를 통해 변환된 IP와 포트 정보를 사용하여 데이터를 전송한다.
- **브리지 모드(SSH, RDP)** 와 **NAT 모드**의 차이가 NAT은 **호스트 컴퓨터의 네트워크 인터페이스**를 통해 외부와 연결된 가상 머신의 트래픽을 처리한다는 것이다.

### 5. **NAT의 주요 기능 요약**
- **IP 주소 변환**: 네트워크 계층에서 NAT는 사설 IP와 공인 IP 간의 변환을 담당.
- **포트 번호 변환**: 전송 계층에서 포트 번호를 변환하여 여러 장치가 동일한 공인 IP를 통해 각각의 서비스로 트래픽을 전달받을 수 있게 함.
- **보안**: NAT는 내부 네트워크 장치들이 외부에 노출되지 않도록 하여 보안성을 높임.

### 6. **정리**
- NAT는 **네트워크 계층(인터넷 계층)** 에서 주로 동작하며, IP 주소 변환을 수행해 외부 네트워크와 통신할 수 있도록 한다.
- **전송 계층**에서는 포트 번호 변환을 통해 트래픽을 올바른 내부 장치로 전달하며, 여러 가상 머신이나 장치가 하나의 공인 IP 주소를 공유할 수 있게 한다.


<br/>
<br/>


## 리눅스 파일 시스템 구조와 inode

### 1. 리눅스 파일 시스템 구조

<img src="https://github.com/user-attachments/assets/cf88c85b-e26e-48ab-a5c5-00f471d28742" width="400">

#### 1.1 슈퍼블록(Superblock)
- **슈퍼블록**은 파일 시스템의 전반적인 메타데이터를 저장하는 공간으로, 파일 시스템 크기, 사용 가능한 inode 및 데이터 블록 수, 파일 시스템 상태 등의 정보를 저장한다.
- 리눅스 파일 시스템이 **마운트**될 때, 슈퍼블록의 정보를 이용해 파일 시스템을 관리한다.

#### 1.2 데이터 블록
- **데이터 블록**은 파일의 **실제 데이터**가 저장되는 공간이다. inode는 이 데이터 블록의 위치를 가리킨다.
- 큰 파일은 여러 데이터 블록에 걸쳐 저장되며, inode는 여러 개의 포인터를 사용해 각 블록을 참조한다.

#### 1.3 inode 테이블
- 파일 시스템에는 **inode 테이블**이 존재하며, 각 inode가 파일에 대한 메타데이터와 파일의 데이터 블록을 가리키는 포인터를 저장한다.
- 이 테이블은 파일 시스템을 생성할 때 미리 생성되며, inode 수는 고정되어 있기 때문에 inode가 부족하면 더 이상 파일을 생성할 수 없게 된다.


### 2. 하드 링크와 소프트 링크
- **inode**와 관련된 중요한 개념 중 하나는 **하드 링크**와 **소프트 링크(심볼릭 링크)** 이다.
- 두 개념은 파일 시스템에서 파일을 참조하는 방식과 관련이 있다.

#### 2.1 하드 링크 (Hard Link)

<image src="https://github.com/user-attachments/assets/1bc39b06-6f93-40ba-b8a0-9b516d5274c3" width="350">

- **하드 링크**는 동일한 inode 번호를 가지는 여러 파일 이름을 의미한다. 즉, 여러 파일 이름이 동일한 파일(하나의 inode)를 가리키는 경우다.
- 동일한 inode 번호를 공유하기 때문에, 파일을 삭제하더라도 다른 하드 링크가 있으면 데이터는 여전히 존재한다.
- 파일의 복제본을 만들고자 할 때 하드 링크를 사용하면 추가적인 디스크 공간을 사용하지 않고 효율적으로 동일한 데이터를 참조할 수 있다.
- 가상화할 때 주의할점은 하드링크는 동일한 파티션, 파일 시스템에서 가능하다는 것이다. 

#### 2.2 소프트 링크 (Soft Link 또는 Symbolic Link)

<img src="https://github.com/user-attachments/assets/cd0fe734-f9da-43bf-b61e-7dfaff0ff63e" width ="300"><br/>
(심볼릭 링크로 연결된 파일을 변경하면 참조하고 있는 모든 파일이 변경된다)

- **소프트 링크**는 특정 파일을 가리키는 별도의 파일로, **다른 파일의 경로**를 참조하는 방식이다. 이는 윈도우의 **바로 가기**와 비슷하다.
- 소프트 링크는 파일 이름을 참조하므로, 원본 파일이 삭제되거나 이동되면 소프트 링크는 깨지게 된다.
- 이는 하드 링크와 달리 원본 파일이 없어지면 링크도 더 이상 유효하지 않게 되는 차이가 있다.

### 3. 파일 시스템 제한 사항
파일 시스템의 제한 사항은 **inode**와 깊은 연관이 있다. 특히, 파일 시스템의 용량과 inode 수는 파일 시스템 성능과 관리에 큰 영향을 미친다.

#### 3.1 inode 수 제한
- 각 파일 시스템에는 **제한된 수의 inode**가 존재한다. 파일 시스템을 생성할 때 inode 테이블이 고정되기 때문에, inode가 부족하면 파일을 생성할 수 없게 된다.
- 대규모 파일 시스템에서는 inode가 소진될 경우 더 이상 파일을 생성할 수 없다.
- 반대로 작은 파일이 많이 존재하는 경우, 디스크 공간이 남아 있어도 inode 부족으로 인해 더 이상 파일을 생성할 수 없는 문제가 발생할 수 있다.

#### 3.2 파일 시스템 용량과 inode
- 파일 시스템 용량이 증가할수록 더 많은 파일을 저장할 수 있지만, **inode 테이블 크기** 역시 충분해야 한다.
- 디스크가 커지면 많은 파일을 저장할 수 있지만, inode 수가 부족하면 더 이상 파일을 추가할 수 없다.

#### 번외: 리눅스 파일의 정대경로와 상대경로

1. 절대경로 (Absolute Path)
  ```bash
  cd /home/user/Documents
  ```
- 절대경로는 **루트 디렉토리(/)** 에서 시작하는 경로로, 파일 시스템 내에서 고정된 위치를 참조한다.

2. 상대경로 (Relative Path)
```bash
cd ../Documents
```
- 상대경로는 **현재 작업 중인 디렉토리**를 기준으로, 상대적인 위치를 참조하는 경로이다


<br/>

