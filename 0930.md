
## 목차

1. [목차1]()


<br/>
<br/>

## 저번주 복습 - 리눅스 파일 시스템 기본 개념

### 파일 시스템
파일 시스템은 데이터를 저장하고 관리하는 방식이다. 저장 장치에 파일을 어떻게 배치하고, 어떻게 읽고 쓸지를 결정한다. 이는 마치 책장에 책을 어떻게 정리하고 분류할지 정하는 것과 같다.

### 블록(Block)
블록은 파일 시스템에서 데이터를 저장하는 **기본 단위**이다. 저장 장치를 일정한 크기의 블록으로 나누어 데이터를 넣고, 파일이 이 블록들에 나뉘어 저장된다.

### inode
inode는 각 파일의 메타데이터(파일 크기, 생성/수정 시간, 권한 등)를 저장하는 **데이터 구조**이다. 파일의 실제 데이터는 블록에 저장되고, inode는 해당 블록들이 어디에 있는지와 같은 정보를 관리한다.

### 디렉터리 구조
리눅스 파일 시스템은 **트리 구조**로 되어 있다. 최상위 디렉터리인 `/`가 모든 파일의 시작점이며, 그 아래로 `/home`, `/var` 등의 하위 디렉터리가 있다. 이는 파일과 폴더가 계층적으로 연결되어 있다는 의미다.

### 주요 디렉터리
- **/**: 루트 디렉터리로, 모든 파일 시스템의 시작점이다.
- **/home**: 각 사용자들의 개인 파일과 설정이 저장되는 디렉터리.
- **/etc**: 시스템의 설정 파일이 저장된 곳.
- **/var**: 로그 파일과 같은 가변적인 데이터가 저장되는 공간.
- **/bin, /sbin, /usr/bin**: 시스템에서 실행 가능한 명령어 및 프로그램들이 위치한 디렉터리. 일반 사용자용 명령어는 **/bin**에, 시스템 관리자는 **/sbin**에서 주로 사용된다.

### 파일 권한 및 소유권
리눅스에서는 각 파일과 디렉터리에 대해 **읽기**, **쓰기**, **실행** 권한이 설정된다. 권한은 파일 소유자, 그룹, 그리고 기타 사용자로 나뉘어 관리된다. 이를 통해 보안이 강화되며, 권한에 따라 파일에 접근할 수 있는 사용자가 달라진다.

<br/>

## NTFS와 FAT 파일 시스템

### FAT(File Allocation Table)

- FAT는 오래된 파일 시스템으로, 간단하고 여러 운영체제에서 호환성이 좋다.
- 주로 USB 메모리나 SD 카드에서 사용되며, 파일 크기 제한이 4GB로 큰 파일을 저장할 수 없다. 디스크 최대 크기도 2TB로 제한된다.

### NTFS(New Technology File System)

- NTFS는 Windows에서 주로 사용하는 파일 시스템으로, 큰 파일과 대용량 드라이브를 지원한다.
- 파일별 권한 설정과 자동 복구 기능을 제공해 보안과 안정성이 뛰어나다. 다만, Windows 외 운영체제에서 파일을 쓸 수 없는 호환성 문제가 있다.

<br/>

## 리눅스 주요 파일 시스템 비교 및 실습

![image](https://github.com/user-attachments/assets/d2ee2a64-5567-4427-a5c5-9340bbd57e6d)

- 리눅스에서 저널링 파일 시스템을 사용하는 ext4 파일 시스템을 실습해보았다.

```bash
# 가상 디스크 파일 생성
# 1GB 크기의 가상 디스크 파일 만듬
# 가상 환경에서 실습을 진행하기 위해 디스크 파일을 만듬. 실제 물리 디스크를 사용하는 대신 가상 디스크 파일 사용.
dd if=/dev/zero of=virtual_disk.img bs=1M count=1024
```
```bash
# ext4 파일 시스템 생성
# 생성한 가상디스크에 ext4 파일 시스템 설치
# 저널링 기능을 이용해보기 위해 ext4(저널링 기능 지원) 파일 시스템 설치
mkfs.ext4 virtual_disk.img
```
```bash
# 가상 디스크 마운트
# 어디에도 사용되지 않는 가상 디바이스를 마운트를 해서 사용
sudo mount -o loop virtual_disk.img /mnt/virtual_disk
```
```bash
# 저널링 기능 확인
tune2fs -l virtual_disk.img | grep has_journal
```
```bash
# 확인 결과 
Filesystem features: has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
```

| **파일 시스템 특성**      | **설명**                                                                                   |
|--------------------------|--------------------------------------------------------------------------------------------|
| `has_journal`             | 저널링 기능이 활성화되어 있어, 시스템 충돌 시 데이터를 안전하게 복구할 수 있음.                |
| `ext_attr`                | 파일과 디렉터리에 확장 속성을 부여할 수 있음.                                                |
| `resize_inode`            | 파일 시스템의 크기를 동적으로 조정할 수 있음.                                                |
| `dir_index`               | 디렉터리 내 파일 검색 속도를 빠르게 하기 위한 B-트리 구조의 인덱스를 사용.                     |
| `filetype`                | 디렉터리 안의 파일 유형을 기록해 파일 탐색 속도를 향상시킴.                                   |
| `needs_recovery`          | 파일 시스템 복구가 필요하다는 의미. 저널을 통해 복구할 수 있는 상태.                            |
| `extent`                  | 연속적인 블록을 사용해 파일을 저장, 디스크 조각화를 줄이고 성능을 향상시킴.                    |
| `64bit`                   | 파일 시스템이 64비트 주소 체계를 사용하여 대형 파일 시스템을 지원.                             |
| `flex_bg`                 | 유연한 블록 그룹을 사용하여 블록을 효율적으로 배치, 성능을 향상시킴.                           |
| `sparse_super`            | 슈퍼블록을 필요한 곳에만 부분적으로 저장하여 저장 공간을 절약하고 성능을 향상시킴.              |
| `large_file`              | 4GB 이상의 대형 파일을 지원할 수 있음.                                                       |
| `huge_file`               | 테라바이트(TB) 단위의 파일을 지원할 수 있음.                                                 |
| `dir_nlink`               | 디렉터리의 하위 디렉터리 개수 제한을 완화, 더 많은 서브디렉터리를 지원.                        |
| `extra_isize`             | inode에 추가적인 공간을 사용하여 더 많은 파일 속성을 저장할 수 있음.                           |
| `metadata_csum`           | 메타데이터의 무결성을 보호하기 위해 체크섬을 사용하여 데이터 손상을 방지함.                    |


<br/>


### ext4: 저널링 지원, 대용량 파일 처리
ext4는 마치 효율적으로 정리된 도서관과 같다. 파일이 빠르고 효율적으로 저장되며, 저널링 기능으로 데이터를 안전하게 보호할 수 있다. 대용량 파일도 잘 처리하며, 안정적이고 믿을 수 있는 파일 시스템이다.

### Btrfs: 스냅샷과 압축 지원
Btrfs는 타임머신이 있는 박물관처럼 스냅샷 기능을 통해 특정 시점으로 돌아가 데이터를 복구할 수 있다. 저장 공간을 자동으로 압축해 공간 효율성도 높으며, 여러 디스크를 한꺼번에 관리할 수 있어 복잡한 데이터 관리에 적합하다.

### XFS: 대용량 데이터 고속 처리
XFS는 고속도로 옆 대형 물류센터처럼 대용량 데이터를 빠르게 처리할 수 있다. 병렬 I/O 처리로 성능이 뛰어나며, 대규모 데이터센터나 고성능 서버 환경에서 주로 사용된다.

### FAT32: 간단한 파일 시스템, 호환성 높음
FAT32는 작은 시골 서점처럼 간단하고 누구나 사용할 수 있는 파일 시스템이다. 다양한 운영체제에서 호환되지만, 4GB 이상의 파일을 처리할 수 없는 제한이 있다. 외부 저장 장치에서 많이 사용된다.

<br/>

## 리눅스의 블록과 파티셔닝

### 블록(Block)
블록은 **저장 장치에서 데이터를 저장하는 가장 작은 단위**이다. 리눅스에서 하드 디스크나 SSD 같은 저장 장치는 작은 블록 단위로 나뉘어 데이터를 저장하고 관리한다. 블록은 일정한 크기로 할당되며, 여러 블록이 모여 하나의 파일이나 데이터를 형성한다. 이는 마치 큰 저장 공간을 작은 칸으로 나누어 관리하는 것과 비슷하다.

### 파티셔닝(Partitioning)
파티셔닝은 **하나의 물리적 저장 장치(HDD, SSD)를 여러 개의 논리적 구역(파티션)으로 나누는 작업**이다. 각 파티션은 독립적으로 운영될 수 있으며, 특정 디렉터리나 데이터를 저장하는 데 사용된다. 리눅스에서는 하나의 디스크를 여러 파티션으로 나누어 운영체제, 사용자 데이터, 로그 파일 등을 각각 별도로 관리할 수 있다.

### 파티션과 파일 시스템
각 파티션에는 **파일 시스템**을 설정할 수 있다. 파일 시스템은 파티션에 저장된 데이터를 어떻게 읽고 쓸지를 결정하는 역할을 한다. 리눅스에서는 **ext4, Btrfs, XFS**와 같은 다양한 파일 시스템을 사용할 수 있으며, 파티션마다 다른 파일 시스템을 할당할 수 있다. 예를 들어, `/home` 파티션에 ext4를 사용하고, `/var` 파티션에 XFS를 사용하는 식이다.

### 블록과 파티션의 역할
- **블록**: 데이터를 저장하는 기본 단위로, 저장 장치를 작은 조각으로 나누어 데이터를 효율적으로 관리한다.
- **파티션**: 블록들을 모아 **논리적 구역**으로 나누어, 각 구역이 독립적으로 데이터를 저장하고 운영될 수 있게 한다.

리눅스에서 블록과 파티셔닝을 통해 **저장 장치를 효율적으로 관리하고**, 다양한 데이터를 구획화하여 책임을 분리해 저장한다.

<br/>
<br/>



## 리눅스의 마운트 포인트, 크기(Size), VG, LV, 파일 시스템 정리

<img width="358" alt="image" src="https://github.com/user-attachments/assets/9f86274c-adb0-4c95-88b8-38b7eb6222be">

### 1. 마운트 포인트(Mount Point)
마운트 포인트는 저장 장치를 파일 시스템에 연결하는 지점이다. 하드디스크나 파티션을 특정 디렉터리에 연결해서 그 저장 공간을 사용할 수 있게 만든다. 리눅스에서는 모든 저장 장치가 특정 디렉터리에 마운트되어야만 데이터를 저장하거나 읽을 수 있다.

- 예시: `/mnt/data`는 마운트 포인트로, 이 디렉터리에 마운트된 저장소의 데이터를 사용할 수 있다.

### 2. 크기(Size)
크기는 저장 장치나 파티션의 물리적 혹은 논리적 공간 크기를 의미한다. 일반적으로 기가바이트(GB), 테라바이트(TB) 등의 단위로 표시되며, 저장소의 용량을 나타낸다.

- 예시: 100GB 크기의 파티션은 최대 100GB의 데이터를 저장할 수 있다.

### 3. VG (Volume Group)
VG는 볼륨 그룹(Volume Group)으로, 여러 개의 물리적인 디스크를 하나의 논리적 그룹으로 묶는 역할을 한다. LVM(논리 볼륨 관리자, Logical Volume Manager)에서 사용하는 개념으로, 물리적 디스크나 파티션을 논리적으로 하나로 묶어 관리할 수 있다.

- 예시: 여러 개의 작은 디스크를 하나의 큰 볼륨 그룹으로 묶어 하나의 큰 저장소처럼 사용할 수 있다.

### 4. LV (Logical Volume)
LV는 논리 볼륨(Logical Volume)으로, VG 안에 있는 저장 공간을 논리적으로 나눈 작은 단위이다. LV는 파티션처럼 작동하며, 파일 시스템을 설치하고 데이터를 저장하는 용도로 사용된다.

- 예시: 1TB 크기의 VG에서 500GB의 LV를 만들어 사용할 수 있다.

### 5. 파일 시스템(File System)
파일 시스템은 데이터를 저장하고 읽는 방식을 정의하는 시스템이다. ext4, Btrfs, XFS 같은 파일 시스템이 있으며, 파일 시스템은 파일을 어떻게 저장하고 관리할지를 결정한다.

- 예시: `mkfs.ext4` 명령어를 사용해 특정 LV에 ext4 파일 시스템을 설치할 수 있다.

### 정리
1. **VG(Volume Group)** 은 물리적 디스크를 묶어서 하나의 논리적 그룹으로 만든다.
2. **LV(Logical Volume)** 는 VG 안에서 특정 크기만큼 할당된 논리적 공간이다.
3. **파일 시스템**은 LV에 적용되어 데이터를 저장하고 관리할 수 있게 한다.
4. **마운트 포인트**는 파일 시스템을 디렉터리에 연결해 데이터를 사용할 수 있게 한다.

#### 파티셔닝 과정 정리 및 실습 스크린샷

<img src="https://github.com/user-attachments/assets/59042968-465c-44cf-b054-3d459e0f8a0a" width="400">

1. 물리 디스크를 나눈다: 먼저 물리 디스크를 여러 파티션으로 나눈다.
2. VG(볼륨 그룹)를 만든다: 여러 물리적 디스크나 파티션을 묶어서 하나의 논리적 그룹(VG)으로 만든다.
3. LV(논리 볼륨)로 나눈다: VG 안에서 필요한 크기만큼 논리적 공간(LV)을 나눈다.
4. 파일 시스템 구축: 각 LV에 ext4, XFS 등 원하는 파일 시스템을 구축한다.
5. 마운트: 마지막으로, 설정한 파일 시스템을 리눅스 파일 시스템 디렉터리에 마운트해서 사용할 수 있게 한다.
6. 이 과정을 통해 물리 디스크를 유연하게 관리하고, 필요한 용도로 논리적으로 나누어 사용할 수 있다.

<br/>

## 리눅스 패키지 관리 

### 1. 패키지(Package)란?
패키지는 특정 소프트웨어를 실행하는 데 필요한 **파일들의 묶음**이다. 실행 파일, 라이브러리, 설정 파일 등이 포함되어 있으며, 리눅스 시스템에서 소프트웨어를 설치하고 관리하는 기본 단위이다.

### 2. 패키지 관리 시스템(Package Manager)이란?
**패키지 관리 시스템**은 리눅스 시스템에서 패키지를 **설치, 업데이트, 제거**하고 **의존성 관리**를 쉽게 할 수 있도록 도와주는 도구다. 각 리눅스 배포판마다 사용하는 패키지 관리 도구가 다를 수 있다.

### 3. 리포지토리(Repository)
리포지토리는 **패키지들을 저장**해두는 중앙 서버로, 패키지 관리 시스템은 여기에서 패키지를 다운로드하고 설치한다. 인터넷을 통해 접근할 수 있으며, 다양한 소프트웨어 패키지가 포함되어 있다.

### 4. 의존성 관리
패키지 관리 시스템은 소프트웨어가 실행되기 위해 필요한 **의존성 패키지**를 자동으로 찾아서 함께 설치해 준다. 이를 통해 사용자는 필요한 소프트웨어만 설치하면 되고, 의존성 문제는 패키지 관리자가 처리해준다.

### 5. 패키지 설치 과정
- **패키지 다운로드**: 패키지 관리 시스템은 리포지토리에서 필요한 패키지를 다운로드한다.
- **파일 시스템에 저장**: 다운로드한 패키지는 리눅스의 **디렉터리 구조에 맞게 자동으로 저장**된다.
  - 예: 실행 파일은 `/usr/bin`에, 설정 파일은 `/etc`에 저장된다.
- **파일 실행**: 파일 시스템에 저장된 실행 파일을 통해 사용자는 소프트웨어를 실행할 수 있다.

### 6. 주요 리눅스 디렉터리와 패키지 파일 저장 경로
- **실행 파일**: `/usr/bin`, `/bin`
  - 패키지의 실행 가능한 파일이 저장된다.
  
- **라이브러리 파일**: `/usr/lib`, `/lib`
  - 소프트웨어가 동작하는 데 필요한 라이브러리 파일들이 저장된다.
  
- **설정 파일**: `/etc`
  - 소프트웨어와 관련된 설정 파일들이 저장된다.
  
- **문서/매뉴얼**: `/usr/share/doc`
  - 설치된 소프트웨어와 관련된 매뉴얼과 문서들이 저장된다.
  
### 7. 패키지 관리 시스템 원리
결국 특정 소프트웨어를 패키지로 받으면 YUM,RPM,Source Install로 알맞은 리눅스 디렉토리에 파일로 저장해주는 것이다.

### 8. 패키지 관리의 중요성
- **편리한 설치 및 관리**: 패키지 관리 시스템은 소프트웨어 설치, 업데이트, 제거를 **명령어 몇 줄로** 쉽게 처리할 수 있게 해준다.
- **자동 의존성 해결**: 패키지가 의존하는 다른 소프트웨어들을 **자동으로 설치**해준다.
- **중앙화된 업데이트**: 시스템 내 모든 소프트웨어를 한 번에 업데이트할 수 있다.


| **항목**          | **YUM**                                     | **RPM**                                    | **Source Install**                          |
|-------------------|---------------------------------------------|--------------------------------------------|--------------------------------------------|
| **설명**          | YUM은 패키지 관리 도구로, **의존성 해결**과 **리포지토리**에서 자동으로 패키지를 설치/업데이트/제거하는 기능을 제공함. | RPM은 Red Hat 기반 시스템에서 사용하는 **패키지 관리 도구**로, **의존성 해결 없이** 개별 패키지를 설치/제거하는 기능을 제공함. | 소스 코드를 직접 다운로드하여 컴파일하고 설치하는 방식. 의존성 및 설치 과정은 수동으로 처리함. |
| **의존성 관리**   | 의존성 자동 해결 (필요한 패키지를 자동으로 설치) | 의존성 자동 해결 기능 없음. 수동으로 패키지 설치 필요 | 의존성 해결은 수동으로 처리해야 함 |
| **리포지토리**    | YUM은 리포지토리에서 패키지를 자동으로 검색하고 다운로드함 | RPM 자체는 리포지토리 없이, 특정 패키지를 수동으로 설치 | 리포지토리 없이 웹사이트나 소스 코드 제공처에서 직접 다운로드 |
| **명령어 예시**   | `sudo yum install package` <br> `sudo yum update package` | `sudo rpm -ivh package.rpm` <br> `sudo rpm -e package` | `./configure` <br> `make` <br> `sudo make install` |
| **유연성**        | 패키지 설치, 제거, 업데이트 모두 간편하게 가능 | 설치는 간편하지만 의존성 관리가 복잡할 수 있음 | 매우 유연하지만, 설치 과정이 복잡하고 시간이 걸림 |
| **사용 상황**     | 의존성 해결과 자동 업데이트가 필요한 상황 | 패키지를 수동으로 설치하고 싶을 때 | 특정 버전의 소프트웨어를 설치하거나 커스터마이징할 때 |
| **속도**          | 자동 설치 및 의존성 관리로 **빠름**            | 의존성 수동 해결 필요 시 **중간**               | **느림** (소스 컴파일 시간에 따라 달라짐) |
| **제어**          | 사용자가 쉽게 사용 가능 (자동화된 처리)        | 중간 수준의 제어 제공                      | 최대한의 제어 가능 (컴파일 옵션 등 설정 가능) |
| **업데이트**      | 패키지를 쉽게 업데이트 가능                    | 수동으로 업데이트해야 함                    | 소스 코드를 다시 받아서 수동으로 업데이트해야 함 |
| **일반 사용 난이도**| **쉬움**                                      | **중간**                                   | **어려움**                                 |

<br/>
<br/>

## 리눅스 패키지 기반으로 라이브러리 관리 원리

### 1. 리눅스 패키지 관리의 핵심 개념
리눅스에서는 **패키지 관리 시스템**을 통해 소프트웨어와 라이브러리를 설치하고 관리한다. 이 시스템은 주로 다음과 같은 역할을 한다:
- **패키지 설치**: 소프트웨어를 설치할 때, 필요한 라이브러리와 의존성을 자동으로 관리한다.
- **디렉터리 구조에 파일 배치**: 설치된 파일들은 리눅스의 **디렉터리 구조**에 맞게 적절한 위치에 배치된다.
  - 예: 실행 파일은 `/usr/bin`, 라이브러리는 `/usr/lib`에 저장된다.

### 2. 패키지 관리와 라이브러리 배치
패키지를 설치할 때, **YUM**, **RPM**, **APT** 등과 같은 패키지 관리 도구는 소프트웨어와 그에 필요한 라이브러리들을 자동으로 찾아서 **리눅스 파일 시스템**에 저장한다. 패키지 관리 도구는 소프트웨어 설치 시 **의존성**을 자동으로 해결하고, **정해진 디렉터리 구조에 맞춰 라이브러리 파일을 배치**한다.

- **실행 파일**: `/usr/bin` 또는 `/bin`에 배치되어 사용자가 명령어로 실행할 수 있다.
- **라이브러리 파일**: `/usr/lib` 또는 `/lib`에 저장되어, 다른 소프트웨어가 해당 라이브러리를 참조할 수 있게 된다.
- **설정 파일**: `/etc` 디렉터리에 배치되어, 해당 소프트웨어의 설정을 관리한다.

### 3. 모바일과 백엔드 개발에서의 라이브러리 관리
- **모바일 개발(Flutter/iOS)**: 모바일 개발에서는 **패키지 관리 도구**로 `pub`(Flutter)과 `CocoaPods`(iOS)을 사용해, 프로젝트에서 필요한 라이브러리를 쉽게 설치하고 관리한다. 이때, 각 패키지는 **프로젝트의 로컬 디렉터리**에 설치된다.
- **백엔드 개발(NestJS)**: 백엔드 개발에서는 **npm**을 사용하여, 프로젝트에서 사용하는 모든 라이브러리를 관리하고 의존성을 해결한다. 라이브러리는 **`node_modules`** 디렉터리에 저장되고, 프로젝트 내에서 참조된다.

이러한 **패키지 관리 도구**들은 **리눅스 패키지 관리 시스템**과 동일한 원리를 따른다. 즉, 패키지를 리포지토리에서 가져와 필요한 파일을 **디렉터리 구조에 맞게 저장**하고, **의존성을 해결**하는 방식으로 동작한다.

### 4. 리눅스에서의 라이브러리 관리와 그 원리
모든 패키지 관리 시스템의 근본적인 원리는 동일하다:
- **리포지토리에서 소프트웨어 패키지를 다운로드**한 후,
- 소프트웨어가 **필요로 하는 라이브러리와 의존성을 자동으로 해결**하고,
- **파일 시스템**에 필요한 파일을 배치하여, 소프트웨어가 실행될 수 있도록 한다.

리눅스에서는 YUM, RPM, APT 등을 통해 시스템에 필요한 소프트웨어와 라이브러리를 설치하고, 프로젝트 단위로는 **npm**이나 **pub**, **CocoaPods**와 같은 패키지 관리 도구를 사용해 각 환경에서 **라이브러리 의존성을 관리**한다.

### 5. 정리
- 요즘 핫한 모바일과 백엔드 개발에서 사용되는 **모듈화 도구**와 **리눅스의 패키지 관리**는 동일한 철학을 공유한다.
- 각각의 패키지나 모듈은 독립적으로 존재하면서도, 필요할 때는 **의존성을 관리**하며 다른 모듈과 연동될 수 있다.
- 이는 리눅스에서 YUM, RPM이 각각의 소프트웨어 패키지를 설치하고, 의존성을 관리하는 방식과 동일한 원리이다.
- **결국 모든 패키지 관리 도구는 리눅스 패키지 관리 시스템의 원리에 기반하고 있다.**
- 각 소프트웨어는 **리포지토리**에서 필요한 패키지를 받아오고, **자동으로 의존성을 해결**하며, 시스템에 맞는 **디렉터리 구조에 파일을 저장**한다.
- **YUM이나 RPM 같은 패키지 관리 도구는 다운로드한 패키지의 파일을 리눅스 파일 시스템의 적절한 디렉터리에 맵핑해서 저장하는 역할을 하는 것이다.**

<br/>
<br/>

## 자바스크립트의 싱글 스레드 비동기 처리와 리눅스 멀티태스킹

### 1. 자바스크립트의 싱글 스레드 비동기 처리
자바스크립트는 **싱글 스레드**로 동작하는 언어지만, **비동기 작업**을 처리할 때 **이벤트 루프(Event Loop)**와 **콜백 큐(callback queue)**를 사용해 동시성을 지원한다. 

- **이벤트 루프**: 자바스크립트의 메인 스레드는 **동기 작업**이 끝나면, 비동기 작업의 **콜백 함수**를 **콜백 큐**에서 가져와 실행한다.
- **비동기 작업 처리**: 자바스크립트는 비동기 작업을 처리하기 위해 **브라우저나 Node.js**에서 제공하는 **백그라운드 스레드**(또는 **스레드 풀**)를 사용한다.

예시: 네트워크 요청을 보낼 때, 자바스크립트는 이를 **백그라운드 스레드**로 넘기고, 작업이 완료되면 **콜백 함수**를 호출하여 **메인 스레드**에서 처리한다.

### 2. Node.js의 libuv와 비동기 작업 처리
**Node.js**는 자바스크립트의 런타임으로, **libuv** 라이브러리를 사용해 **비동기 작업**을 처리한다.

- **libuv**는 **스레드 풀**을 제공하며, 파일 I/O, 네트워크 요청 등 **비동기 작업**을 처리한다.
- 작업이 완료되면 **이벤트 루프**로 결과를 전달하여, 자바스크립트의 **메인 스레드**에서 작업을 이어서 실행한다.

### 3. 리눅스 커널의 멀티태스킹과 스레드 관리
자바스크립트의 비동기 작업이 **백그라운드 스레드**에서 처리될 때, 실제로는 **리눅스 커널**이 해당 스레드를 관리하고, **멀티태스킹**을 통해 **CPU 자원**을 할당해 실행한다.

- **프로세스 스케줄러**: 리눅스 커널은 **프로세스 스케줄러**를 통해 각 스레드가 **CPU 시간을 할당**받아 작업을 처리할 수 있도록 한다.
- **컨텍스트 스위칭**: 여러 스레드는 **컨텍스트 스위칭**을 통해 짧은 시간 동안 CPU 자원을 번갈아 가며 사용하게 된다.

### 4. CPU에서의 비동기 작업 처리
- **단일 코어 CPU**에서는 CPU가 작업들을 **빠르게 교대**하며 처리한다.
- **멀티코어 CPU**에서는 여러 작업이 실제로 **병렬로 처리**될 수 있다.

### 전체 과정 요약
1. **자바스크립트의 비동기 처리**: 비동기 작업은 자바스크립트의 **이벤트 루프**와 **백그라운드 스레드**를 통해 처리된다.
2. **libuv와 스레드 풀**: Node.js는 **libuv**의 **스레드 풀**을 통해 비동기 작업을 병렬로 처리한다.
3. **리눅스 멀티태스킹**: 리눅스 커널의 **프로세스 스케줄러**가 스레드를 관리하고, **멀티태스킹**을 통해 CPU에서 작업이 처리된다.
4. **CPU 처리**: CPU는 **단일 코어**에서 **시간 분할**로, **멀티코어**에서 **병렬로** 작업을 처리한다.

<br/>
<br/>

## 리눅스 멀티태스킹: 백그라운드와 포그라운드

### 1. 멀티태스킹 개념
리눅스는 **멀티태스킹** 운영체제로, 한 번에 여러 작업(프로세스)을 처리할 수 있다. 이를 통해 여러 프로세스를 **동시에 실행하는 것처럼** 보이게 하고, 작업들을 **포그라운드**와 **백그라운드**로 나누어 관리한다.

- **포그라운드(Foreground)**: 사용자가 직접 명령어를 실행한 후, 결과를 즉시 확인할 수 있는 프로세스. 프로세스가 끝날 때까지 터미널을 사용할 수 없다.
- **백그라운드(Background)**: 프로세스가 **백그라운드에서 실행**되며, 프로세스가 실행되는 동안에도 터미널에서 다른 명령어를 실행할 수 있다.

#### 예시:
```bash
sleep 10   # 포그라운드에서 10초 대기
sleep 10 & # 백그라운드에서 10초 대기
```
### 2. 프로세스 관리
리눅스에서 실행 중인 프로세스는 포그라운드에서 사용자가 직접 제어하거나, 백그라운드에서 실행되며 시스템에 의해 관리된다. 프로세스 관리는 ps, top, jobs 같은 명령어를 사용해 할 수 있다.

- **ps**: 현재 실행 중인 프로세스를 확인할 수 있는 명령어.
- **top**: 실시간으로 시스템의 프로세스 상태와 자원 사용량을 모니터링하는 명령어.
- **jobs**: 백그라운드에서 실행 중인 작업 목록을 보여주는 명령어.
 
### 3. 시그널과 프로세스 제어
리눅스에서는 프로세스를 제어하기 위해 **시그널(signal)**을 사용한다. 시그널은 프로세스에 특정 동작을 지시하는 신호로, 프로세스를 종료하거나 일시 중지하는 데 사용된다.

#### 주요 시그널:
- **SIGTERM** (15): 프로세스에 종료 요청을 보낸다. 프로세스는 종료 신호를 받으면 정리 작업을 하고 종료된다.
- **SIGKILL** (9): 강제 종료 시그널. 프로세스에 정리할 기회를 주지 않고 즉시 종료시킨다.
- **SIGSTOP**: 프로세스를 일시 중지시킨다.
- **SIGCONT**: 일시 중지된 프로세스를 다시 실행시킨다.

```bash
kill -SIGTERM <PID>  # PID에 해당하는 프로세스를 정상적으로 종료
kill -SIGKILL <PID>  # PID에 해당하는 프로세스를 강제 종료
kill -SIGSTOP <PID>  # 프로세스를 일시 중지
kill -SIGCONT <PID>  # 일시 중지된 프로세스를 재개
```

### 4. 백그라운드와 포그라운드 프로세스 제어
#### 포그라운드에서 백그라운드로 전환
포그라운드에서 실행 중인 프로세스를 Ctrl + Z로 일시 정지한 후, bg 명령어로 백그라운드에서 재개할 수 있다.
```bash
sleep 100  # 포그라운드에서 실행
Ctrl + Z   # 일시 중지
bg         # 백그라운드에서 재개
```

#### 백그라운드에서 포그라운드로 전환:
백그라운드에서 실행 중인 프로세스를 fg 명령어로 포그라운드에서 실행할 수 있다.

```
fg  # 백그라운드에서 포그라운드로 전환
```


### 5. 간단한 명령어와 결과 예시


```bash
# 1. ps 명령어로 현재 실행 중인 프로세스 확인
ps
# 결과 예시:
# PID TTY          TIME CMD
# 1234 pts/0    00:00:00 bash
# 5678 pts/0    00:00:05 sleep

# 2. sleep 100 명령어를 백그라운드로 실행
sleep 100 &
# 결과 예시: [1] 12345  (프로세스 번호가 12345로 백그라운드에서 실행됨)

# 3. 백그라운드 프로세스 목록 확인
jobs
# 결과 예시: 
# [1]+  Running                 sleep 100 &

# 4. 프로세스 강제 종료
kill -9 12345
# 결과: 프로세스 12345가 종료됨
```
<br/>
<br/>

## DNS와 NAT를 통한 요청 처리 과정

### 1. **DNS 변환**
- 사용자가 **www.google.com** 과 같은 도메인 이름을 입력하면, **DNS(Domain Name System)** 이 이 도메인 이름을 **IP 주소**로 변환한다.
- 예: `www.google.com` -> `142.250.190.14` (구글 서버의 공용 IP 주소)

### 2. **IP 주소 + 포트 번호**
- 변환된 **IP 주소**와 **포트 번호**(기본적으로 **80번 포트(HTTP)** 또는 **443번 포트(HTTPS)**)를 사용해, 사용자의 컴퓨터는 구글 서버로 **HTTP/HTTPS 요청**을 보낸다.
- 예: `142.250.190.14:443` (HTTPS 요청)

### 3. **구글 서버가 공용 IP로 요청을 받음**
- 구글 서버는 **공용 IP 주소**를 통해 네트워크 외부에서 들어오는 요청을 받는다.
- 이 요청은 구글의 **NAT(Network Address Translation)** 시스템을 거쳐 **내부 네트워크**로 전달될 준비가 된다.

### 4. **NAT를 통한 내부 IP 변환**
- **NAT**는 공용 IP 주소로 받은 요청을 **구글 내부 네트워크의 IP 주소**로 변환하여 내부의 특정 서버로 라우팅한다.
- 예: `142.250.190.14` -> `10.0.0.5` (구글 내부 서버의 IP 주소)

### 5. **포트 번호로 특정 프로그램 실행**
- 내부 서버로 전달된 요청은 **포트 번호**에 따라 해당 요청을 처리할 **프로그램(서비스)**으로 전달된다.
- 예:
  - **80번 포트**: 웹 서버(Apache, Nginx 등)가 요청을 처리
  - **443번 포트**: HTTPS 웹 서버가 요청을 처리

### 6. **서브넷 마스크**
- **서브넷 마스크**는 네트워크 내부에서 **IP 주소를 구분**하는 데 사용된다. 구글 서버로 들어온 요청이 **NAT**를 통해 내부 네트워크로 변환될 때, 내부의 여러 **서브넷**으로 분리된 네트워크에서 **서브넷 마스크**가 각 장치(IP 주소)를 구분하는 역할을 한다.
- 예를 들어, 구글의 내부 네트워크가 **서브넷 마스크 255.255.255.0(/24)** 로 나누어져 있다면, **NAT**는 해당 요청을 **192.168.1.0/24** 서브넷으로 라우팅하여, 그 안의 **특정 서버(예: 192.168.1.5)** 로 요청을 보낼 수 있다.
- **서브넷 마스크**는 요청이 내부 네트워크로 들어온 후 **네트워크와 호스트 부분을 구분**하고, **NAT**가 적절한 서브넷 안의 장치로 요청을 라우팅하는 데 사용된다.

<br/>
<br/>

## OSI 4계층으로 구글 접속 과정 살펴보기
![image](https://github.com/user-attachments/assets/b22e7845-d321-419a-9d37-9aa4f58834ba)

| **단계**                      | **OSI 계층**                                        |
|-------------------------------|----------------------------------------------------|
| 1. **DNS 변환**                | **애플리케이션 계층 (7계층)**                       |
| 2. **IP 주소 + 포트 번호**      | **애플리케이션 계층 (7계층), 전송 계층 (4계층)**    |
| 3. **구글 서버가 요청을 받음** | **네트워크 계층 (3계층)**                          |
| 4. **NAT를 통한 내부 IP 변환** | **네트워크 계층 (3계층)**                          |
| 5. **포트 번호로 프로그램 실행**| **전송 계층 (4계층)**                              |
| 6. **서브넷 마스크**           | **네트워크 계층 (3계층)**                          |

<br/>

| **계층**                | **역할**                                                                                         | **프로토콜 및 사용 기술**                                     | **설명**                                                                                                          |
|-------------------------|-------------------------------------------------------------------------------------------------|-------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------|
| **애플리케이션 계층 (7계층)** | **HTTP/HTTPS 요청을 생성** 및 웹 브라우저와 서버 간의 상호작용을 담당                                | HTTP, HTTPS                                                | 사용자가 **www.google.com** 을 입력하면, **브라우저**가 **HTTP/HTTPS** 요청을 생성하여 서버에 연결을 시도한다.       |
| **전송 계층 (4계층)**        | **데이터의 신뢰성 있는 전송**을 보장하고, **TCP 연결**을 설정                                          | TCP, UDP                                                   | **TCP**를 사용하여 **3-way 핸드셰이크**로 연결을 설정하고, 데이터를 **패킷** 단위로 나누어 전송한다.                |
| **네트워크 계층 (3계층)**     | **IP 주소를 사용해 데이터 패킷을 라우팅**하고 목적지 서버로 전달                                       | IP (Internet Protocol)                                     | **DNS**를 통해 구글의 **IP 주소**를 얻고, 이를 바탕으로 패킷을 **네트워크 상에서 경로 설정**하여 구글 서버로 보낸다.|
| **데이터 링크 계층 (2계층)**  | **이더넷 프레임과 MAC 주소**를 사용해 **로컬 네트워크**에서 데이터 전송                               | Ethernet, MAC 주소                                         | 네트워크의 물리적 링크(케이블, 무선)를 통해 **이더넷 프레임**이 **라우터** 등 네트워크 장치로 전달된다.            |

<br/>

### 전체 과정 요약

| **단계**                        | **설명**                                                                                                       |
|----------------------------------|--------------------------------------------------------------------------------------------------------------|
| **1. 애플리케이션 계층 (7계층)**  | 사용자가 **www.google.com** 을 입력하면, 브라우저가 **HTTP/HTTPS** 요청을 생성한다.                               |
| **2. 전송 계층 (4계층)**         | **TCP**를 사용해 **3-way 핸드셰이크**로 서버와 연결을 설정하고, 데이터를 **패킷**으로 나누어 전송한다.              |
| **3. 네트워크 계층 (3계층)**      | **IP 주소**를 사용해 패킷이 **인터넷 상에서 경로 설정**되고, 정확한 구글 서버로 전송된다.                           |
| **4. 데이터 링크 계층 (2계층)**   | **이더넷 프레임**과 **MAC 주소**를 사용해 **로컬 네트워크** 상에서 데이터를 전송하고, **물리적 링크**를 통해 전달한다.  |

