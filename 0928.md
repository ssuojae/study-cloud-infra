
## 목차

1. [목차1]()


<br/>
<br/>

## 저번주 복습 - 리눅스 파일 시스템 기본 개념

### 파일 시스템
파일 시스템은 데이터를 저장하고 관리하는 방식이다. 저장 장치에 파일을 어떻게 배치하고, 어떻게 읽고 쓸지를 결정한다. 이는 마치 책장에 책을 어떻게 정리하고 분류할지 정하는 것과 같다.

### 블록(Block)
블록은 파일 시스템에서 데이터를 저장하는 **기본 단위**이다. 저장 장치를 일정한 크기의 블록으로 나누어 데이터를 넣고, 파일이 이 블록들에 나뉘어 저장된다.

### inode
inode는 각 파일의 메타데이터(파일 크기, 생성/수정 시간, 권한 등)를 저장하는 **데이터 구조**이다. 파일의 실제 데이터는 블록에 저장되고, inode는 해당 블록들이 어디에 있는지와 같은 정보를 관리한다.

### 디렉터리 구조
리눅스 파일 시스템은 **트리 구조**로 되어 있다. 최상위 디렉터리인 `/`가 모든 파일의 시작점이며, 그 아래로 `/home`, `/var` 등의 하위 디렉터리가 있다. 이는 파일과 폴더가 계층적으로 연결되어 있다는 의미다.

### 주요 디렉터리
- **/**: 루트 디렉터리로, 모든 파일 시스템의 시작점이다.
- **/home**: 각 사용자들의 개인 파일과 설정이 저장되는 디렉터리.
- **/etc**: 시스템의 설정 파일이 저장된 곳.
- **/var**: 로그 파일과 같은 가변적인 데이터가 저장되는 공간.
- **/bin, /sbin, /usr/bin**: 시스템에서 실행 가능한 명령어 및 프로그램들이 위치한 디렉터리. 일반 사용자용 명령어는 **/bin**에, 시스템 관리자는 **/sbin**에서 주로 사용된다.

### 파일 권한 및 소유권
리눅스에서는 각 파일과 디렉터리에 대해 **읽기**, **쓰기**, **실행** 권한이 설정된다. 권한은 파일 소유자, 그룹, 그리고 기타 사용자로 나뉘어 관리된다. 이를 통해 보안이 강화되며, 권한에 따라 파일에 접근할 수 있는 사용자가 달라진다.

<br/>

## NTFS와 FAT 파일 시스템

### FAT(File Allocation Table)

- FAT는 오래된 파일 시스템으로, 간단하고 여러 운영체제에서 호환성이 좋다.
- 주로 USB 메모리나 SD 카드에서 사용되며, 파일 크기 제한이 4GB로 큰 파일을 저장할 수 없다. 디스크 최대 크기도 2TB로 제한된다.

### NTFS(New Technology File System)

- NTFS는 Windows에서 주로 사용하는 파일 시스템으로, 큰 파일과 대용량 드라이브를 지원한다.
- 파일별 권한 설정과 자동 복구 기능을 제공해 보안과 안정성이 뛰어나다. 다만, Windows 외 운영체제에서 파일을 쓸 수 없는 호환성 문제가 있다.

<br/>

## 리눅스 주요 파일 시스템 비교 및 실습

![image](https://github.com/user-attachments/assets/d2ee2a64-5567-4427-a5c5-9340bbd57e6d)

- 리눅스에서 저널링 파일 시스템을 사용하는 ext4 파일 시스템을 실습해보았다.

```bash
# 가상 디스크 파일 생성
# 1GB 크기의 가상 디스크 파일 만듬
# 가상 환경에서 실습을 진행하기 위해 디스크 파일을 만듬. 실제 물리 디스크를 사용하는 대신 가상 디스크 파일 사용.
dd if=/dev/zero of=virtual_disk.img bs=1M count=1024
```
```bash
# ext4 파일 시스템 생성
# 생성한 가상디스크에 ext4 파일 시스템 설치
# 저널링 기능을 이용해보기 위해 ext4(저널링 기능 지원) 파일 시스템 설치
mkfs.ext4 virtual_disk.img
```
```bash
# 가상 디스크 마운트
# 어디에도 사용되지 않는 가상 디바이스를 마운트를 해서 사용
sudo mount -o loop virtual_disk.img /mnt/virtual_disk
```
```bash
# 저널링 기능 확인
tune2fs -l virtual_disk.img | grep has_journal
```
```bash
# 확인 결과 
Filesystem features: has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
```

| **파일 시스템 특성**      | **설명**                                                                                   |
|--------------------------|--------------------------------------------------------------------------------------------|
| `has_journal`             | 저널링 기능이 활성화되어 있어, 시스템 충돌 시 데이터를 안전하게 복구할 수 있음.                |
| `ext_attr`                | 파일과 디렉터리에 확장 속성을 부여할 수 있음.                                                |
| `resize_inode`            | 파일 시스템의 크기를 동적으로 조정할 수 있음.                                                |
| `dir_index`               | 디렉터리 내 파일 검색 속도를 빠르게 하기 위한 B-트리 구조의 인덱스를 사용.                     |
| `filetype`                | 디렉터리 안의 파일 유형을 기록해 파일 탐색 속도를 향상시킴.                                   |
| `needs_recovery`          | 파일 시스템 복구가 필요하다는 의미. 저널을 통해 복구할 수 있는 상태.                            |
| `extent`                  | 연속적인 블록을 사용해 파일을 저장, 디스크 조각화를 줄이고 성능을 향상시킴.                    |
| `64bit`                   | 파일 시스템이 64비트 주소 체계를 사용하여 대형 파일 시스템을 지원.                             |
| `flex_bg`                 | 유연한 블록 그룹을 사용하여 블록을 효율적으로 배치, 성능을 향상시킴.                           |
| `sparse_super`            | 슈퍼블록을 필요한 곳에만 부분적으로 저장하여 저장 공간을 절약하고 성능을 향상시킴.              |
| `large_file`              | 4GB 이상의 대형 파일을 지원할 수 있음.                                                       |
| `huge_file`               | 테라바이트(TB) 단위의 파일을 지원할 수 있음.                                                 |
| `dir_nlink`               | 디렉터리의 하위 디렉터리 개수 제한을 완화, 더 많은 서브디렉터리를 지원.                        |
| `extra_isize`             | inode에 추가적인 공간을 사용하여 더 많은 파일 속성을 저장할 수 있음.                           |
| `metadata_csum`           | 메타데이터의 무결성을 보호하기 위해 체크섬을 사용하여 데이터 손상을 방지함.                    |


<br/>


### ext4: 저널링 지원, 대용량 파일 처리
ext4는 마치 효율적으로 정리된 도서관과 같다. 파일이 빠르고 효율적으로 저장되며, 저널링 기능으로 데이터를 안전하게 보호할 수 있다. 대용량 파일도 잘 처리하며, 안정적이고 믿을 수 있는 파일 시스템이다.

### Btrfs: 스냅샷과 압축 지원
Btrfs는 타임머신이 있는 박물관처럼 스냅샷 기능을 통해 특정 시점으로 돌아가 데이터를 복구할 수 있다. 저장 공간을 자동으로 압축해 공간 효율성도 높으며, 여러 디스크를 한꺼번에 관리할 수 있어 복잡한 데이터 관리에 적합하다.

### XFS: 대용량 데이터 고속 처리
XFS는 고속도로 옆 대형 물류센터처럼 대용량 데이터를 빠르게 처리할 수 있다. 병렬 I/O 처리로 성능이 뛰어나며, 대규모 데이터센터나 고성능 서버 환경에서 주로 사용된다.

### FAT32: 간단한 파일 시스템, 호환성 높음
FAT32는 작은 시골 서점처럼 간단하고 누구나 사용할 수 있는 파일 시스템이다. 다양한 운영체제에서 호환되지만, 4GB 이상의 파일을 처리할 수 없는 제한이 있다. 외부 저장 장치에서 많이 사용된다.

<br/>

## 리눅스의 블록과 파티셔닝

### 블록(Block)
블록은 **저장 장치에서 데이터를 저장하는 가장 작은 단위**이다. 리눅스에서 하드 디스크나 SSD 같은 저장 장치는 작은 블록 단위로 나뉘어 데이터를 저장하고 관리한다. 블록은 일정한 크기로 할당되며, 여러 블록이 모여 하나의 파일이나 데이터를 형성한다. 이는 마치 큰 저장 공간을 작은 칸으로 나누어 관리하는 것과 비슷하다.

### 파티셔닝(Partitioning)
파티셔닝은 **하나의 물리적 저장 장치(HDD, SSD)를 여러 개의 논리적 구역(파티션)으로 나누는 작업**이다. 각 파티션은 독립적으로 운영될 수 있으며, 특정 디렉터리나 데이터를 저장하는 데 사용된다. 리눅스에서는 하나의 디스크를 여러 파티션으로 나누어 운영체제, 사용자 데이터, 로그 파일 등을 각각 별도로 관리할 수 있다.

### 파티션과 파일 시스템
각 파티션에는 **파일 시스템**을 설정할 수 있다. 파일 시스템은 파티션에 저장된 데이터를 어떻게 읽고 쓸지를 결정하는 역할을 한다. 리눅스에서는 **ext4, Btrfs, XFS**와 같은 다양한 파일 시스템을 사용할 수 있으며, 파티션마다 다른 파일 시스템을 할당할 수 있다. 예를 들어, `/home` 파티션에 ext4를 사용하고, `/var` 파티션에 XFS를 사용하는 식이다.

### 블록과 파티션의 역할
- **블록**: 데이터를 저장하는 기본 단위로, 저장 장치를 작은 조각으로 나누어 데이터를 효율적으로 관리한다.
- **파티션**: 블록들을 모아 **논리적 구역**으로 나누어, 각 구역이 독립적으로 데이터를 저장하고 운영될 수 있게 한다.

리눅스에서 블록과 파티셔닝을 통해 **저장 장치를 효율적으로 관리하고**, 다양한 데이터를 구획화하여 책임을 분리해 저장한다.

<br/>
<br/>



## 리눅스의 마운트 포인트, 크기(Size), VG, LV, 파일 시스템 정리

<img width="358" alt="image" src="https://github.com/user-attachments/assets/9f86274c-adb0-4c95-88b8-38b7eb6222be">

### 1. 마운트 포인트(Mount Point)
마운트 포인트는 저장 장치를 파일 시스템에 연결하는 지점이다. 하드디스크나 파티션을 특정 디렉터리에 연결해서 그 저장 공간을 사용할 수 있게 만든다. 리눅스에서는 모든 저장 장치가 특정 디렉터리에 마운트되어야만 데이터를 저장하거나 읽을 수 있다.

- 예시: `/mnt/data`는 마운트 포인트로, 이 디렉터리에 마운트된 저장소의 데이터를 사용할 수 있다.

### 2. 크기(Size)
크기는 저장 장치나 파티션의 물리적 혹은 논리적 공간 크기를 의미한다. 일반적으로 기가바이트(GB), 테라바이트(TB) 등의 단위로 표시되며, 저장소의 용량을 나타낸다.

- 예시: 100GB 크기의 파티션은 최대 100GB의 데이터를 저장할 수 있다.

### 3. VG (Volume Group)
VG는 볼륨 그룹(Volume Group)으로, 여러 개의 물리적인 디스크를 하나의 논리적 그룹으로 묶는 역할을 한다. LVM(논리 볼륨 관리자, Logical Volume Manager)에서 사용하는 개념으로, 물리적 디스크나 파티션을 논리적으로 하나로 묶어 관리할 수 있다.

- 예시: 여러 개의 작은 디스크를 하나의 큰 볼륨 그룹으로 묶어 하나의 큰 저장소처럼 사용할 수 있다.

### 4. LV (Logical Volume)
LV는 논리 볼륨(Logical Volume)으로, VG 안에 있는 저장 공간을 논리적으로 나눈 작은 단위이다. LV는 파티션처럼 작동하며, 파일 시스템을 설치하고 데이터를 저장하는 용도로 사용된다.

- 예시: 1TB 크기의 VG에서 500GB의 LV를 만들어 사용할 수 있다.

### 5. 파일 시스템(File System)
파일 시스템은 데이터를 저장하고 읽는 방식을 정의하는 시스템이다. ext4, Btrfs, XFS 같은 파일 시스템이 있으며, 파일 시스템은 파일을 어떻게 저장하고 관리할지를 결정한다.

- 예시: `mkfs.ext4` 명령어를 사용해 특정 LV에 ext4 파일 시스템을 설치할 수 있다.

### 정리
1. **VG(Volume Group)** 은 물리적 디스크를 묶어서 하나의 논리적 그룹으로 만든다.
2. **LV(Logical Volume)** 는 VG 안에서 특정 크기만큼 할당된 논리적 공간이다.
3. **파일 시스템**은 LV에 적용되어 데이터를 저장하고 관리할 수 있게 한다.
4. **마운트 포인트**는 파일 시스템을 디렉터리에 연결해 데이터를 사용할 수 있게 한다.

#### 파티셔닝 과정 정리 및 실습 스크린샷

<img src="https://github.com/user-attachments/assets/59042968-465c-44cf-b054-3d459e0f8a0a" width="400">


1. 물리 디스크를 나눈다: 먼저 물리 디스크를 여러 파티션으로 나눈다.
2. VG(볼륨 그룹)를 만든다: 여러 물리적 디스크나 파티션을 묶어서 하나의 논리적 그룹(VG)으로 만든다.
3. LV(논리 볼륨)로 나눈다: VG 안에서 필요한 크기만큼 논리적 공간(LV)을 나눈다.
4. 파일 시스템 구축: 각 LV에 ext4, XFS 등 원하는 파일 시스템을 구축한다.
5. 마운트: 마지막으로, 설정한 파일 시스템을 리눅스 파일 시스템 디렉터리에 마운트해서 사용할 수 있게 한다.
6. 이 과정을 통해 물리 디스크를 유연하게 관리하고, 필요한 용도로 논리적으로 나누어 사용할 수 있다.
