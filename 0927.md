
## 목차

1. [목차1]()


<br/>
<br/>

## 어제했던 실습 내용 복습 -> 리눅스 파일 권한 및 속성 이해

### bash 명령어
```bash
-rw-r--r-- 1 root root 0 Sep 26 12:39 a.txt

truncate -s 100M test.txt

dd if=/dev/zero of=대상디렉토리 bs=100M count=1
```

### 1. 파일 권한 및 속성
- **파일 권한**: `-rw-r--r--`은 파일의 권한을 나타냄
  - 첫 번째 `-`: 파일 타입을 의미함. `-`는 일반 파일, `d`는 디렉토리, `l`은 심볼릭 링크
  - `rw-`: 소유자(Owner)의 권한. 읽기(`r`), 쓰기(`w`)가 가능하고, 실행(`x`)은 불가능함
  - `r--`: 그룹(Group)의 권한. 읽기(`r`)만 가능하며, 쓰기(`w`)와 실행(`x`)은 불가능함
  - `r--`: 기타 사용자(Others)의 권한. 읽기(`r`)만 가능하며, 쓰기(`w`)와 실행(`x`)은 불가능함

- **하드링크 수**: `1`은 해당 파일을 가리키는 링크의 수를 의미함
- **소유자와 그룹**: `root root`는 해당 파일의 소유자가 `root`, 그룹도 `root`임을 나타냄
- **파일 크기**: `0`은 해당 파일의 크기가 0바이트임을 의미함
- **마지막 수정 날짜 및 시간**: `Sep 26 12:39`은 파일이 마지막으로 수정된 날짜와 시간을 의미함
- **파일 이름**: `a.txt`는 파일의 이름임

### 2. 권한 분석
- **소유자 권한 (rw-)**: 소유자는 읽기(`r`)와 쓰기(`w`) 권한을 가짐
- **그룹 권한 (r--)**: 그룹은 읽기(`r`)만 가능하며, 쓰기(`w`)와 실행(`x`)은 불가능함
- **기타 사용자 권한 (r--)**: 기타 사용자는 읽기(`r`)만 가능하며, 쓰기(`w`)와 실행(`x`)은 불가능함

### 3. 기타 파일 속성
- **`.`**: `.`는 ACL(Access Control List)이 설정되어 있지 않음을 의미함. 만약 ACL이 설정되어 있으면 `+`가 표시됨
- **하드링크 수**: `1`은 파일을 가리키는 하드링크의 수를 나타냄
- **소유자와 그룹**: `root root`는 해당 파일의 소유자와 그룹을 의미함
- **파일 크기**: 파일의 크기는 0바이트

## 4. 명령어 설명

- **`truncate -s`**: 파일의 크기를 조정할 때 사용되는 명령어로, 원하는 크기로 파일을 만들거나 조정할 수 있음
- **`dd if=/dev/zero of=대상디렉토리 bs=100M count=1`**: 빈 파일을 생성하거나 크기를 테스트할 때 자주 사용하는 명령어. 주로 용량 테스트를 위해 사용됨

<br/>


<img width="500" alt="image" src="https://github.com/user-attachments/assets/1c9d7da2-1f77-4e85-bc54-820654c94386">

- `group`: 기본그룹
- `home`: 홈 디렉토리 기본설정
- `INACTIVE=-1`: 유예기간(패스워드 최대 사용기간이 생성되어야만 유예기간 활성화)
- `SHELL=/bin/bash`: 기본 shell
- `SKEL=/etc/skel`: 사용자의 홈디렉토리에 복사되는 파일 및 디렉토리 위치
- `CREATE_MAIL_SPOOL=yes`: mail 사서함 생성 여부


<br/>
<br/>

## sh와 bash의 차이

| 항목            | `/bin/sh` (Bourne Shell)     | `/bin/bash` (Bourne Again Shell)  |
|-----------------|-----------------------------|----------------------------------|
| **출시 시기**   | 1979년 (Unix 초기 버전)      | 1989년 (Bourne Shell의 확장판)    |
| **기능**        | 기본적인 명령어 실행, POSIX 표준 | 고급 기능 (명령어 자동 완성, 배열, 명령어 기록 등) |
| **호환성**      | 더 많은 Unix 계열 시스템에서 동작  | 대부분의 Linux 시스템에서 사용 가능하지만, 호환성은 sh보다 적음 |
| **스크립트**     | 더 간단한 스크립트에 적합         | 복잡한 스크립트와 시스템 관리 작업에 적합  |
| **자동 완성**    | 지원하지 않음                  | 지원 (탭 키로 명령어 및 파일 이름 자동 완성) |
| **명령어 히스토리** | 기본적으로 지원하지 않음          | 히스토리 기능을 지원하여 이전에 입력한 명령어를 쉽게 재사용 가능 |
| **배열 지원**    | 지원하지 않음                  | 배열(Array) 사용 가능              |
| **일반적인 용도** | 간단한 스크립트, POSIX 준수 작업  | 복잡한 스크립트, 고급 시스템 관리 작업    |


- **출시 시기**: `/bin/sh`는 Unix 시스템에서 기본적으로 사용된 오래된 쉘로, 1979년에 처음 나왔고, 가장 단순하고 보편적인 쉘이다. 반면, **bash**는 1989년에 이 기본 쉘을 확장하고 더 많은 기능을 제공하기 위해 탄생했다.
  
- **기능 차이**: **bash**는 **sh**보다 훨씬 더 많은 기능을 제공한다. 특히, 배열 사용, 명령어 자동 완성, 히스토리 기능 등이 포함되어 있어 복잡한 스크립트를 작성할 때 유용하다. **sh**는 기본적인 명령어 실행과 간단한 스크립트 작성에 적합하며, 시스템 간의 호환성에 더 신경 쓰는 환경에서 많이 쓰인다.

- **호환성**: **sh**는 더 많은 Unix 계열 시스템에서 표준적으로 사용되기 때문에, 다양한 환경에서 동일하게 동작하는 **호환성**이 장점이다. 반면, **bash**는 더 많은 기능을 제공하지만, 모든 Unix 시스템에서 반드시 동일하게 동작하지 않을 수 있다.

- **스크립트 작성**: 간단한 명령어나 시스템에서의 자동화 작업에는 **sh**가 충분하지만, 복잡한 제어 흐름(예: `if`, `while`, `for`)이나 다양한 기능을 요구하는 작업은 **bash**가 더 적합하다.

- **자동 완성 및 히스토리 기능**: **bash**는 명령어 자동 완성과 명령어 히스토리를 기본적으로 제공한다. 이를 통해 사용자가 더 효율적으로 작업할 수 있도록 도와준다. 반면, **sh**는 이러한 편리한 기능이 부족하다.

- 결론적으로, **sh**는 더 가벼운 작업이나 호환성이 중요한 환경에서, **bash**는 복잡하고 고급 기능이 필요한 작업에서 적합하다고 할 수 있다.


<br/>
<br/>

## SELinux 

### SELinux란?
**SELinux(Security-Enhanced Linux)** 는 Linux 시스템에서 보안 정책을 통해 파일, 프로세스, 네트워크 자원에 대한 접근을 세밀하게 제어하는 보안 확장 모듈이다. 이를 통해 시스템 보안을 강화할 수 있다.

### SELinux의 제어과정
<img src="https://github.com/user-attachments/assets/e3db22a3-e3d7-473e-8190-b868a17c3f3a" width="400">

1. **AVC(Access Vector Cache)에서 요청 확인**:
   - 주체가 객체에 접근하려는 요청이 들어오면, **AVC**에서 이전에 같은 요청이 있었는지 확인한다.
   - 만약 이전에 처리된 요청이 있다면, 캐시된 결과를 사용하여 빠르게 결론을 내린다.

2. **주체가 객체에 대한 권한이 있는지 확인**:
   - SELinux는 **Security Policies(보안 정책)** 을 확인하여, 주체가 객체에 접근할 권한이 있는지 확인한다.
   - 보안 정책에 따라 주체가 할 수 있는 작업(읽기, 쓰기, 실행 등)을 결정한다.

3. **보안 정책에 따른 접근 허용 또는 차단 결정**:
   - **Security Policies**에 기반해 접근을 **허용**할지 **차단**할지 결정한다.
   - 주체가 정책에 맞는 권한을 가지고 있으면 접근이 허용되고, 그렇지 않으면 차단된다.

### 핵심 용어
- **주체(Subject)**: 접근을 시도하는 사용자 또는 프로세스.
- **객체(Object)**: 접근 대상(파일, 디렉토리, 네트워크 자원 등).
- **AVC(Access Vector Cache)**: 과거 요청의 결과를 캐시하여 빠르게 접근을 결정하는 공간.
- **Security Policies**: 시스템 관리자가 설정한 보안 규칙으로, 주체가 객체에 대한 접근 권한을 결정.



### `setenforce`란?
`setenforce`는 SELinux의 **실행 모드**를 설정하는 명령어로, 시스템의 보안 정책이 어떻게 적용되는지를 결정한다.

### SELinux 모드
SELinux는 주로 세 가지 실행 모드를 제공한다.

1. **Enforcing (강제 모드)**:
   - **SELinux 보안 정책이 강제적으로 적용**된다.
   - 정책에 어긋나는 액세스는 **차단**된다.
   - 예: 어떤 프로세스가 특정 파일에 접근할 수 없도록 정책이 설정되어 있다면, Enforcing 모드에서는 그 접근이 차단된다.

2. **Permissive (허용 모드)**:
   - 정책 위반이 발생해도 **접근이 허용**되지만, **로그에 기록**된다.
   - SELinux 정책을 디버깅하거나 테스트할 때 유용하다.

3. **Disabled (비활성화 모드)**:
   - **SELinux가 완전히 꺼진 상태**이다.
   - 정책이 전혀 적용되지 않는다.
   - `setenforce` 명령어로는 이 모드로 전환할 수 없으며, `/etc/selinux/config` 파일을 수정한 후 시스템을 재부팅해야 한다.

### `setenforce` 명령어 사용법

- **Enforcing 모드로 전환**:
    ```bash
    setenforce 1
    ```
    SELinux를 **Enforcing** 모드로 전환하여 정책을 강제 적용한다.

- **Permissive 모드로 전환**:
    ```bash
    setenforce 0
    ```
    SELinux를 **Permissive** 모드로 전환하여 정책 위반 사항을 허용하면서 로그에 기록한다.

### `getenforce` 명령어
현재 SELinux 모드를 확인할 때 사용하는 명령어로, **Enforcing**, **Permissive**, **Disabled** 중 현재 설정된 모드를 출력한다.

- **SELinux 모드 확인**:
    ```bash
    getenforce
    ```

### 실제 사용 사례
- **시스템 디버깅**: SELinux 정책으로 인해 서비스가 정상적으로 작동하지 않을 경우, 일시적으로 **Permissive 모드**로 전환하여 로그를 기록하면서 원인을 파악할 수 있다.
- **보안 테스트**: SELinux 정책을 테스트할 때 **Permissive** 모드를 활용하여 정책 위반 상황을 기록하고, 실제로 차단하지 않으면서도 로그로 문제를 확인할 수 있다.
- **운영 환경**: 실제 서버 운영 시에는 보안 강화를 위해 SELinux를 **Enforcing 모드**로 유지하는 것이 일반적이다. 하지만 일부 애플리케이션이 SELinux와 충돌할 경우, 상황에 맞게 모드를 적절히 변경해야 한다.


<br/>
<br/>

## 전통적인 리눅스 권한 vs SELinux 비교해보기

### 1. 전통적인 리눅스 권한 (setuid, setgid, sticky bit)

- **setuid**:
  - 프로그램이 실행될 때, **해당 파일의 소유자** 권한으로 실행.
  - 예: `passwd` 프로그램은 root 권한으로 실행되어 시스템 파일 수정 가능.

- **setgid**:
  - 파일이나 디렉토리를 **그룹 권한**으로 실행하거나 접근.
  - 디렉토리에 적용 시, 생성되는 파일들이 그 디렉토리의 그룹 소유권을 상속.

- **sticky bit**:
  - 디렉토리에서 **자신이 만든 파일만 삭제** 가능.
  - 예: `/tmp` 디렉토리에서 여러 사용자가 파일을 만들 수 있지만, 만든 사람만 삭제 가능.

#### 전통적인 권한의 특징
- **보안 모델**: DAC (Discretionary Access Control)
- **권한 관리 주체**: 파일 소유자와 그룹
- **적용 대상**: 파일과 디렉토리
- **주 사용 목적**: 간단한 권한 관리 및 접근 제어
- **세밀한 제어**: 상대적으로 제한적

<br/>

### 2. SELinux

- **SELinux**는 리눅스 커널에 내장된 **보안 모듈**로, 더 세밀한 보안 정책을 제공.
- **MAC (Mandatory Access Control)** 기반으로 작동하여, 사용자가 설정한 권한보다 더 강력한 정책을 적용.
- 정책을 통해 프로세스, 파일, 네트워크 자원 등의 접근을 **더욱 세밀하게 제어**할 수 있음.

#### SELinux의 특징
- **보안 모델**: MAC (Mandatory Access Control)
- **권한 관리 주체**: 시스템 관리자 또는 보안 정책
- **적용 대상**: 시스템 전체 (파일, 프로세스, 네트워크 등)
- **주 사용 목적**: 복잡한 보안 환경에서 전체 시스템 보안 강화
- **세밀한 제어**: 매우 세밀한 보안 정책 적용 가능

<br/>

### 3. 전통적인 리눅스 권한 vs SELinux 비교

| 항목                   | 전통적인 리눅스 권한 (setuid, setgid, sticky bit) | SELinux |
|------------------------|-------------------------------------------------|---------|
| **보안 모델**           | DAC (Discretionary Access Control)              | MAC (Mandatory Access Control) |
| **권한 관리 주체**      | 파일 소유자와 그룹                              | 시스템 관리자 또는 보안 정책 |
| **적용 대상**           | 파일과 디렉토리                                | 시스템 전체 (파일, 프로세스, 네트워크) |
| **세밀한 제어 가능성**  | 제한적                                        | 매우 세밀한 정책 적용 가능 |
| **보안 적용 범위**      | 특정 파일/디렉토리에 한정                      | 전체 시스템 보안 강화 |
| **사용 목적**           | 간단한 권한 관리 및 접근 제어                   | 복잡한 보안 환경에서 전체 시스템 보호 |

<br/>

### 4. 결론

- **전통적인 리눅스 권한 관리 방식**은 **setuid, setgid, sticky bit** 등을 사용하여 파일 및 디렉토리의 접근을 간단하게 제어하는 데 유용함.
- **SELinux**는 더 **복잡하고 민감한 보안 요구**에 대응하기 위한 강력한 보안 모듈로, 시스템 전반에 걸친 세밀한 보안 제어를 가능하게 함.
- **두 방식은 서로 보완적**이며, 전통적인 권한 방식은 간단한 보안 관리에, SELinux는 고급 보안 요구 사항을 충족하기 위한 도구로 사용됨.

<br/>
<br/>

## Linux Storaage

### Storage란 무엇인가?

Storage는 데이터를 **물리적으로 저장**하는 공간이다. 리눅스에서는 이 Storage가 **파일 시스템**의 일부로 작동하며, 다양한 디렉토리나 파일에 데이터를 저장하고 불러오는 데 사용된다. 이 Storage는 데이터가 저장되는 **하드웨어 장치**일 수도 있고, 네트워크를 통해 연결된 외부 장치일 수도 있다.

비유적으로 설명하자면, **리눅스 시스템을 하나의 큰 집**이라고 할 때, Storage는 그 집 안에 있는 **옷장, 선반, 서랍장**과 같은 역할을 한다. 각 방(디렉토리)마다 **특정한 역할**이 있듯이, 이 방 안의 서랍(스토리지)에 물건(데이터)을 보관하게 된다.

즉, **Storage는 데이터가 실제로 저장되는 공간**이며, 리눅스 시스템의 여러 디렉토리에 연결되어 사용자가 데이터를 쉽게 저장하고 불러올 수 있게 해주는 핵심 역할을 한다.

### 리눅스에서의 Storage 역할

리눅스의 파일 시스템은 여러 **디렉토리**로 구성되며, Storage는 각 디렉토리에서 데이터를 **어디에 저장하고 어떻게 접근할지**를 관리한다. 예를 들어:

- **/home**: 사용자 파일을 저장하는 공간.
- **/var**: 시스템 로그나 데이터베이스 파일 등을 저장하는 공간.
- **/mnt**: 외부 Storage를 연결해 사용하는 공간.
- **/srv**: 서버 데이터를 저장하는 공간.

Storage는 디렉토리가 데이터의 **경로**를 제공하고, 그 경로에 따라 데이터를 **물리적으로 저장하는 역할**을 한다.

### DAS, NAS, SAN 비교

리눅스에서 Storage는 다양한 방식으로 연결될 수 있는데, 그 중 대표적인 방식이 **DAS**, **NAS**, **SAN**이다. 각각의 Storage 방식은 데이터가 저장되는 위치와 접근 방법에 차이가 있다.

| **항목**     | **DAS (Direct Attached Storage)**      | **NAS (Network Attached Storage)** | **SAN (Storage Area Network)**   |
|--------------|----------------------------------------|------------------------------------|---------------------------------|
| **접속 방식** | 서버에 직접 연결된 스토리지               | 네트워크를 통해 파일 시스템에 접근    | 네트워크를 통해 블록 스토리지에 접근 |
| **성능**     | 빠름 (네트워크 없이 직접 연결)              | 네트워크 성능에 의존, 보통 빠름       | 매우 빠름 (전용 네트워크 사용)    |
| **확장성**   | 제한적 (서버에 직접 연결되므로 확장 어려움)    | 중간 (네트워크 통해 확장 가능)        | 매우 높음 (대규모 확장 가능)      |
| **공유 가능성**| 불가능 (서버 간 스토리지 공유 어려움)        | 가능 (여러 서버가 스토리지를 공유)    | 가능 (여러 서버와 공유 가능)      |
| **사용 사례** | 소규모 서버, 개인용 스토리지                | 파일 공유 서버, 중소규모 환경         | 고성능 데이터베이스, 가상화 환경   |

#### 1. **DAS (Direct Attached Storage)**
   - 서버에 직접 연결된 스토리지.
   - 빠르고 설정이 간단하지만, 확장성이나 공유가 어려움.

#### 2. **NAS (Network Attached Storage)**
   - 네트워크를 통해 연결된 스토리지로, 여러 서버나 클라이언트가 접근 가능.
   - 파일 시스템 수준에서 접근하며, 파일 공유에 적합.

#### 3. **SAN (Storage Area Network)**
   - 전용 네트워크를 통해 연결된 고성능 스토리지.
   - 블록 스토리지로 동작하며, 데이터베이스나 대규모 가상화 환경에서 사용됨.

#### 요약
리눅스에서 Storage는 **파일과 데이터를 물리적으로 저장하는 공간**이며, 디렉토리 구조와 함께 시스템이 데이터를 어떻게 관리할지를 결정한다. DAS, NAS, SAN은 각기 다른 스토리지 방식으로, 시스템의 크기, 요구 성능에 따라 적합한 방식을 선택할 수 있다.

### DAS, NAS, SAN의 동작 원리 비유

각 스토리지 방식의 동작 원리를 쉽게 이해하기 위해 비유를 사용해보자.

#### 1. **DAS (Direct Attached Storage)**
   - **비유**: DAS는 **내 책상 위에 있는 서랍**과 같아. 내가 바로 옆에 있는 서랍을 열어서 필요한 물건을 바로바로 꺼내 쓸 수 있지. 다른 사람과 공유할 수 없지만, 내 손에 닿는 곳에 있으니까 아주 빠르고 효율적으로 물건을 사용할 수 있어.
   - **배운 내용**: 서버에 직접 연결된 스토리지로, 성능이 빠르고 설정이 간단하지만 확장성과 공유 기능이 부족하다.

#### 2. **NAS (Network Attached Storage)**
   - **비유**: NAS는 **거실에 있는 공유 선반**과 같아. 우리 가족이 모두 거실에 있는 선반에 물건을 넣고 빼면서 쓸 수 있어. 집 안 어디서든 쉽게 접근할 수 있지만, 한 번에 여러 명이 사용하면 속도가 조금 느려질 수 있지.
   - **배운 내용**: 네트워크를 통해 파일 시스템에 접근하며, 여러 서버나 클라이언트가 동시에 스토리지를 공유할 수 있다. 다만 네트워크 속도에 의존한다.

#### 3. **SAN (Storage Area Network)**
   - **비유**: SAN은 **우리 집과 직접 연결된 고속도로**라고 생각하면 돼. 이 고속도로를 통해 멀리 있는 대형 창고와 연결되어 있어. 나는 아주 빠른 속도로 물건을 가져오고, 여러 사람도 이 고속도로를 통해 창고에 쉽게 접근할 수 있어. 확장성도 뛰어나서 필요한 만큼 더 많은 창고를 연결할 수 있어.
   - **배운 내용**: 전용 네트워크를 통해 블록 스토리지에 접근하며, 고성능을 요구하는 데이터베이스나 대규모 가상화 환경에서 주로 사용된다. 성능과 확장성이 뛰어나지만, 비용이 높고 관리가 복잡하다.

## 결국 리눅스에서 DAS, NAS, SAN은 각각 다른 방식으로 데이터를 저장하고 접근할 수 있도록 해준다.  
- **DAS**는 가장 빠르고 단순하지만 확장성이 부족하고, 
- **NAS**는 파일을 여러 서버에서 공유하기 적합하며, 
- **SAN**은 고성능과 대규모 확장을 필요로 하는 경우에 적합하다.

<br/>
<br/>

## Cloud Storage

### Cloud Storage란?

**Cloud Storage**는 데이터를 **물리적인 하드웨어가 아닌 인터넷을 통해 외부 서버에 저장**하는 방식이다. 사용자는 로컬 서버나 컴퓨터에 데이터를 저장하는 대신, **클라우드 제공자의 데이터 센터**에 데이터를 저장하며, 인터넷을 통해 언제 어디서나 그 데이터에 접근할 수 있다.

### Cloud Storage의 비유적인 설명

**Cloud Storage**를 비유하자면, **내 집에 있는 옷장이나 서랍을 사용하는 대신, 도시에 있는 거대한 창고를 이용하는 것**과 같다. 

- 집에 옷장이 부족할 때, 더 큰 옷장을 사는 대신 도시의 대형 창고에 물건을 맡기고, 필요할 때마다 그 창고에서 물건을 꺼내 쓸 수 있는 것과 같은 원리다.
- 내가 이사하거나 여행 중이더라도, 이 창고는 언제든지 **인터넷만 있으면 내가 물건을 꺼내 쓸 수 있도록** 제공된다.
- 창고를 관리하는 직원이 있어서, 내가 직접 청소나 유지 보수를 할 필요 없이 **안전하게 물건을 보관**할 수 있다.

즉, Cloud Storage는 데이터를 어디서나 접근 가능하고, 쉽게 확장할 수 있는 **인터넷 기반의 데이터 저장 공간**이다.

### Cloud Storage의 장점
1. **어디서나 접근 가능**: 마치 도시에 있는 창고에서 언제든지 물건을 가져올 수 있듯이, 클라우드 스토리지는 인터넷만 있으면 어디서든 데이터를 접근할 수 있다.
2. **확장성**: 집에 서랍이 부족할 때 새로 살 필요 없이, 창고 공간을 쉽게 더 확보할 수 있듯이 클라우드 스토리지는 필요에 따라 저장 용량을 확장할 수 있다.
3. **관리 용이성**: 내 집의 옷장 관리는 내가 하지만, 클라우드 스토리지는 클라우드 제공자가 데이터를 안전하게 관리하고 백업까지 책임져준다.

### 정리

- Cloud Storage는 **인터넷을 통해 데이터를 저장하고 관리하는 방식**으로, 내가 직접 하드웨어를 관리할 필요 없이 **데이터를 안전하게 보관하고 언제 어디서나 쉽게 접근할 수 있는 편리한 솔루션**이다.
- 클라우드 스토리지는 내가 필요한 만큼 확장할 수 있고, 다양한 기기에서 쉽게 사용할 수 있기 때문에 개인 사용자뿐만 아니라 기업에서도 널리 사용되고 있다.


<br/>
<br/>

## 블록 스토리지와 파일 스토리지

### 1. 블록 스토리지 (Block Storage)

- **블록 스토리지**는 데이터를 **고정된 크기의 블록 단위로 나누어** 저장하는 방식이다.
- 각 블록은 독립적으로 관리되며, 운영체제는 이를 **로컬 디스크**처럼 인식한다. 주로 **SAN(Storage Area Network)** 이나 **클라우드 스토리지** 환경에서 사용된다.

#### 특징
- **블록 단위 저장**: 데이터를 **고정 크기의 블록**으로 나누어 저장한다.
- **운영체제가 파일 시스템을 생성**: 블록 스토리지에 운영체제가 직접 **파일 시스템을 설정**한다.
- **고성능, 유연성**: 성능이 뛰어나며, 데이터베이스나 가상 머신(VM)처럼 **빠른 데이터 접근**이 필요한 환경에 적합하다.

#### 비유
- **블록 스토리지**는 **레고 블록**과 같다. 각 블록이 독립적으로 존재하며, 이를 조합해서 하나의 큰 구조물을 만들 수 있다. 하지만 각 블록은 그 자체로 독립적이기 때문에, 다른 블록이 어떤 구조물의 일부분인지 알 필요는 없다.

#### 사용 사례
- **SAN**(Storage Area Network) 환경
- **클라우드**에서 제공하는 **EBS**(Elastic Block Store)
- **데이터베이스**나 **가상화 환경**에서 주로 사용됨

<br/>

### 2. 파일 스토리지 (File Storage)

**파일 스토리지**는 데이터를 **파일 단위**로 저장하고, **디렉토리 구조**를 통해 관리하는 방식이다. 파일 시스템이 포함되어 있으며, **파일 경로**를 통해 데이터에 접근한다. **NAS(Network Attached Storage)** 와 같은 네트워크 스토리지 환경에서 많이 사용된다.

#### 특징
- **파일 단위 저장**: 데이터를 파일 단위로 저장하며, **디렉토리와 파일명**을 통해 관리한다.
- **파일 시스템 포함**: 파일 스토리지는 기본적으로 파일 시스템을 포함하고, 디렉토리 구조를 통해 데이터를 쉽게 탐색할 수 있다.
- **네트워크 공유에 적합**: 여러 사용자가 네트워크를 통해 파일에 접근할 수 있어, 파일 공유와 협업 환경에 적합하다.

#### 비유
- **파일 스토리지**는 **도서관의 책장**과 같다. 각 책이 **파일**이고, 책장은 **디렉토리** 역할을 한다. 책을 찾기 위해서는 **책장의 위치**와 **책의 이름**을 알아야 한다. 여러 사람이 동시에 책장에 접근해도 문제없다.

#### 사용 사례
- **NAS**(Network Attached Storage) 환경
- **네트워크 파일 공유** 서버
- 팀 협업을 위한 파일 공유 시스템

<br/>

### 3. 블록 스토리지와 파일 스토리지의 차이점

| **항목**            | **블록 스토리지 (Block Storage)**                        | **파일 스토리지 (File Storage)**                  |
|---------------------|-----------------------------------------------------------|---------------------------------------------------|
| **저장 단위**       | 데이터를 **블록** 단위로 나눠서 저장                      | 데이터를 **파일** 단위로 저장                      |
| **파일 시스템 관리** | **운영체제**가 직접 파일 시스템을 설정하고 관리            | **스토리지 자체**가 파일 시스템을 제공하고 관리     |
| **데이터 접근 방식** | 데이터는 **블록**으로 나뉘어 저장되며, 블록을 통해 접근   | 데이터를 **디렉토리 구조**와 **파일 이름**으로 접근 |
| **성능**            | 고성능, 빠른 I/O가 필요할 때 유리                         | 여러 사용자가 파일을 공유할 때 유리                |
| **사용 환경**       | **DAS**, **SAN**, **클라우드 스토리지**, 데이터베이스, 가상화       | **NAS**, 파일 서버, 협업 환경                      |
| **확장성**          | 고성능 확장성이 뛰어남                                    | 공유 기능이 강력하고 여러 사용자 지원 가능          |




<br/>
<br/>

## Swap과 Mount

### 1. Swap: 메모리 부족을 해결하는 임시 공간

#### Swap이란?
**Swap**은 **RAM(메모리)**이 부족할 때, **하드디스크나 SSD**의 일부를 **임시 메모리**로 사용하는 공간이다. 리눅스 시스템에서 물리적 메모리가 부족할 때, Swap 공간을 사용해 프로그램이 중단되지 않고 계속 실행되도록 도와준다.

#### 비유적으로 설명하자면:
- **RAM은 책상**이고, **Swap은 바닥**과 같다. 책상이 너무 좁아서 자료를 더 놓을 수 없을 때, 자료를 바닥(Swap)에 임시로 두고 필요할 때 다시 가져오는 방식이다. 하지만 바닥에서 자료를 꺼내는 속도는 책상에서 꺼내는 것보다 훨씬 느리다.

#### Swap의 역할:
- **메모리 부족 방지**: RAM이 부족할 때 시스템이 멈추지 않고 Swap 공간을 이용해 데이터를 처리한다.
- **시스템 안정성 유지**: RAM 부족으로 인해 발생하는 프로그램 중단을 방지해 시스템의 안정성을 높인다.
- **성능 저하**: Swap 공간은 RAM보다 느리기 때문에 자주 사용되면 시스템 성능이 떨어질 수 있다.

#### Swap의 구성:
- **Swap 파티션**: 하드디스크나 SSD의 일부를 미리 할당해 Swap 공간으로 사용하는 방식.
- **Swap 파일**: 기존 디스크 공간에서 파일 형태로 생성하여 Swap 공간으로 사용하는 방식.

<br/>

### 2. Mount: 파일 시스템을 특정 디렉토리에 연결하는 과정

#### Mount란?
**Mount**는 **디스크, USB 드라이브, 네트워크 스토리지** 같은 장치나 파일 시스템을 리눅스의 **특정 디렉토리에 연결**하는 과정이다. 마운트된 파일 시스템은 마치 로컬 디렉토리처럼 리눅스 시스템에서 접근할 수 있다.

#### 비유적으로 설명하자면:
- **Mount**는 **새로운 방을 집에 연결**하는 것과 비슷하다. USB 드라이브나 외장 하드를 연결해서 그 안의 데이터를 사용하려면 리눅스 파일 시스템에 **마운트 포인트**라는 방을 만들어야 한다. 이렇게 연결된 방(디렉토리)을 통해 데이터를 자유롭게 사용할 수 있다.

#### Mount의 역할:
- **외부 장치 연결**: 외장 하드, USB 드라이브, 네트워크 스토리지 등의 외부 장치를 리눅스 시스템에 연결해 파일을 사용할 수 있게 한다.
- **디스크 파티션 사용**: 하드디스크나 SSD의 여러 파티션을 시스템의 파일 시스템에 마운트해 데이터를 사용할 수 있게 한다.
- **유연한 파일 시스템**: 마운트 포인트를 통해 다양한 파일 시스템을 쉽게 관리할 수 있다.

<br/>

### Swap과 Mount의 차이점

- **Swap**은 주로 **메모리 부족을 해결**하기 위해 디스크 공간을 사용한다. RAM이 부족할 때 디스크 공간을 메모리처럼 사용해 시스템 성능을 유지하지만, 디스크 속도는 RAM보다 느리기 때문에 성능 저하가 발생할 수 있다.
- **Mount**는 **디스크나 외부 장치를 파일 시스템에 연결**하는 과정이다. USB 드라이브, 외장 하드, 네트워크 스토리지 등을 리눅스 시스템의 특정 디렉토리에 연결해 데이터를 읽고 쓸 수 있다.

<br/>

### 코드 예제

#### Swap 설정 예제

```bash
# 시스템에서 사용 중인 스왑 영역 확인
swapon -s

# 스왑 파일 생성 및 설정
sudo fallocate -l 2G /swapfile    # 2GB 크기의 스왑 파일 생성
sudo chmod 600 /swapfile          # 스왑 파일 권한 설정
sudo mkswap /swapfile             # 스왑 파일 형식 지정
sudo swapon /swapfile             # 스왑 파일 활성화
```


Mount 설정 예제
```bash
# USB 드라이브를 /mnt/usb 디렉토리에 마운트
sudo mount /dev/sdb1 /mnt/usb

# 마운트된 장치 목록 확인
mount

# 마운트 해제
sudo umount /mnt/usb
```

<br/>
<br/>

## SATA, SSD, SCSI 비교

<img src="https://github.com/user-attachments/assets/c595826d-49eb-4318-abb1-cb67aaf3817d" width="400">

- **SATA**: 디스크와 컴퓨터 간의 연결 방식.
- **SSD**: 데이터를 저장하는 장치 자체.
- **SCSI**: 고성능 장치와 서버 간 연결 인터페이스.

### 1. SATA: 고속도로

**SATA**는 데이터를 전송하는 **고속도로**로 비유할 수 있다.
- 이 고속도로는 **모든 차**(HDD나 SSD 같은 저장 장치)가 사용할 수 있다.
- **속도는 제법 빠르지만**, 최신 스포츠카(고성능 SSD)가 달릴 때는 **최대 속도를 못 낼 수 있다**.
- 기존 도로를 업그레이드한 형태라 **설치도 쉽고, 많은 기기가 사용할 수 있는** 장점이 있다.

#### 비유
- **SATA는 기존의 고속도로**. 모든 차가 달릴 수 있지만, 더 빠른 차는 제 속도를 내지 못할 때가 있다.
- **장점**: **저렴하고 범용적**이라 많은 곳에서 사용된다.
- **단점**: 고성능 장치를 연결할 때 **속도의 한계**가 있다.

<br/>

### 2. SSD: 고속 기차

**SSD**는 데이터를 저장하는 장치로, **고속 기차**와 비슷하다.
- 기차는 **궤도**를 따라 빠르게 달리며, 기계적 방식의 **자동차(HDD)**보다 훨씬 빠르다.
- **SSD는 전자적 방식**을 사용해 데이터를 처리하므로, 속도가 매우 빠르고, **고장 날 위험이 적다**.

#### 비유
- **SSD는 고속 기차**. **빠르고 효율적**으로 데이터를 처리하며, 내구성도 뛰어나다.
- **장점**: 매우 **빠른 속도**와 **안정성**.
- **단점**: 가격이 비쌀 수 있고, **SATA 인터페이스**로 연결할 때 속도의 한계가 있을 수 있다.

<br/>

### 3. SCSI: 대형 물류 시스템

**SCSI**는 고성능 서버 환경에서 데이터를 처리하는 **대형 물류 시스템**과 같다.
- **SCSI는 여러 방향에서 동시에** 데이터를 처리할 수 있고, 많은 장치들이 연결돼도 효율적으로 관리할 수 있다.
- **서버**나 대형 스토리지 환경에서 주로 사용되며, 안정적이고 빠른 데이터 처리에 적합하다.

#### 비유
- **SCSI는 대형 물류 허브 시스템**. **복잡하지만 매우 효율적**으로 대규모 데이터를 처리할 수 있다.
- **장점**: **고성능**, 여러 장치를 동시에 연결해도 안정적.
- **단점**: **설치와 관리가 복잡**하고, 고가일 수 있다. 주로 서버 환경에서 사용된다.

<br/>

### 비유로 정리한 비교

| **기술**    | **비유**                    | **장점**                           | **단점**                                 |
|-------------|-----------------------------|------------------------------------|------------------------------------------|
| **SATA**    | 고속도로                    | 저렴하고 설치가 쉬움, 범용적 사용 가능 | 최신 SSD 같은 고속 장치는 속도 제한이 있음   |
| **SSD**     | 고속 기차                    | 매우 빠르고 내구성이 좋음            | 가격이 비쌀 수 있음, SATA에서는 속도 한계가 있음 |
| **SCSI**    | 대형 물류 시스템             | 고성능, 여러 장치 동시 연결 및 처리   | 설치 및 관리가 복잡하고, 주로 고가 서버에서 사용됨  |

<br/>
<br/>

## 볼륨(Volume)이란?

### 1. 볼륨(Volume)이란?
**볼륨(Volume)** 은 **저장 장치 내에서 데이터를 저장하는 논리적인 공간**을 말한다. 하드 디스크나 SSD 같은 물리적인 저장 장치에서 **데이터를 저장할 수 있는 공간을 논리적으로 나눈 단위**다. 물리적 디스크를 여러 개의 논리적인 단위로 나누거나, 여러 디스크를 묶어서 하나의 큰 공간으로 만들 수 있다.

### 2. 볼륨을 비유하자면
- **볼륨**은 **집의 땅**처럼 생각할 수 있다. 이 땅을 **어떻게 구획으로 나누고 사용할지**는 내가 정할 수 있다.
  - 전통적인 방식에서는 이 땅을 **여러 개의 구획(파티션)**으로 나눠서 각각 다른 용도로 사용했다.
  - **볼륨**을 사용하면 이 땅을 **더 유연하게 관리할 수 있는 가상의 공간**으로 바꿀 수 있다. 즉, 필요한 만큼 나눌 수도 있고, 여러 땅을 합쳐서 하나의 큰 공간으로 만들 수도 있다.
  
### 3. 볼륨 관련 용어

<img src="https://github.com/user-attachments/assets/0d3b72f0-cafd-476e-a359-34220db22c5d" width="450">

- **물리적 볼륨(PV)**: 실제로 존재하는 **물리적 디스크나 파티션**.
- **볼륨 그룹(VG)**: 여러 물리적 볼륨을 하나로 묶어 **큰 저장 공간**을 만들 수 있다.
- **논리적 볼륨(LV)**: 볼륨 그룹에서 필요한 만큼 용량을 할당해 만든 **가상의 파티션**으로, 크기 조정이 유연하다.

### 4. 볼륨을 사용한 관리
- **LVM(Logical Volume Manager)** 을 사용하면, 여러 개의 물리적 볼륨을 **하나의 큰 논리적 볼륨**으로 묶어서 유연하게 관리할 수 있다.
- **논리적 볼륨**을 만들면, 그 안에서 데이터를 저장하고 관리할 공간을 자유롭게 나누고 크기를 조정할 수 있다.
  
### 5. 볼륨의 사용 사례
- **서버와 데이터센터**: 여러 디스크를 묶어서 **유연하게 저장 공간을 관리**하고, 필요에 따라 크기를 조정할 수 있다.
- **가상화 환경**: 가상 서버와 컨테이너 환경에서 **독립된 저장 공간**을 논리적 볼륨으로 제공하여 쉽게 관리할 수 있다.

### 6. 볼륨과 파티션의 차이
- **파티션**: 물리적 디스크를 여러 개의 구획으로 나누는 전통적인 방식.
- **볼륨**: 물리적 또는 논리적 저장 공간을 더 유연하게 관리할 수 있는 단위. 여러 디스크를 합쳐 하나로 사용하거나, 필요에 따라 크기를 조정할 수 있다.

| **항목**    | **설명**                                                    | **비유**                          |
|-------------|-------------------------------------------------------------|-----------------------------------|
| **파티션**  | 물리적 디스크를 여러 논리적 영역으로 나눈 것. 블록 단위로 데이터를 관리 | 책꽂이의 구획처럼 데이터를 구역별로 나누어 저장 |
| **볼륨**    | 논리적 저장 장치로, 여러 파티션을 하나의 큰 공간처럼 사용하거나, 나누어서 사용 | 도서관의 섹션처럼 데이터를 파일 단위로 관리 |
