
## 목차

1. [목차1]()


<br/>
<br/>

## 어제했던 실습 내용 복습 -> 리눅스 파일 권한 및 속성 이해

### bash 명령어
```bash
-rw-r--r-- 1 root root 0 Sep 26 12:39 a.txt

truncate -s 100M test.txt

dd if=/dev/zero of=대상디렉토리 bs=100M count=1
```

### 1. 파일 권한 및 속성
- **파일 권한**: `-rw-r--r--`은 파일의 권한을 나타냄
  - 첫 번째 `-`: 파일 타입을 의미함. `-`는 일반 파일, `d`는 디렉토리, `l`은 심볼릭 링크
  - `rw-`: 소유자(Owner)의 권한. 읽기(`r`), 쓰기(`w`)가 가능하고, 실행(`x`)은 불가능함
  - `r--`: 그룹(Group)의 권한. 읽기(`r`)만 가능하며, 쓰기(`w`)와 실행(`x`)은 불가능함
  - `r--`: 기타 사용자(Others)의 권한. 읽기(`r`)만 가능하며, 쓰기(`w`)와 실행(`x`)은 불가능함

- **하드링크 수**: `1`은 해당 파일을 가리키는 링크의 수를 의미함
- **소유자와 그룹**: `root root`는 해당 파일의 소유자가 `root`, 그룹도 `root`임을 나타냄
- **파일 크기**: `0`은 해당 파일의 크기가 0바이트임을 의미함
- **마지막 수정 날짜 및 시간**: `Sep 26 12:39`은 파일이 마지막으로 수정된 날짜와 시간을 의미함
- **파일 이름**: `a.txt`는 파일의 이름임

### 2. 권한 분석
- **소유자 권한 (rw-)**: 소유자는 읽기(`r`)와 쓰기(`w`) 권한을 가짐
- **그룹 권한 (r--)**: 그룹은 읽기(`r`)만 가능하며, 쓰기(`w`)와 실행(`x`)은 불가능함
- **기타 사용자 권한 (r--)**: 기타 사용자는 읽기(`r`)만 가능하며, 쓰기(`w`)와 실행(`x`)은 불가능함

### 3. 기타 파일 속성
- **`.`**: `.`는 ACL(Access Control List)이 설정되어 있지 않음을 의미함. 만약 ACL이 설정되어 있으면 `+`가 표시됨
- **하드링크 수**: `1`은 파일을 가리키는 하드링크의 수를 나타냄
- **소유자와 그룹**: `root root`는 해당 파일의 소유자와 그룹을 의미함
- **파일 크기**: 파일의 크기는 0바이트

## 4. 명령어 설명

- **`truncate -s`**: 파일의 크기를 조정할 때 사용되는 명령어로, 원하는 크기로 파일을 만들거나 조정할 수 있음
- **`dd if=/dev/zero of=대상디렉토리 bs=100M count=1`**: 빈 파일을 생성하거나 크기를 테스트할 때 자주 사용하는 명령어. 주로 용량 테스트를 위해 사용됨

<br/>


<img width="500" alt="image" src="https://github.com/user-attachments/assets/1c9d7da2-1f77-4e85-bc54-820654c94386">

- `group`: 기본그룹
- `home`: 홈 디렉토리 기본설정
- `INACTIVE=-1`: 유예기간(패스워드 최대 사용기간이 생성되어야만 유예기간 활성화)
- `SHELL=/bin/bash`: 기본 shell
- `SKEL=/etc/skel`: 사용자의 홈디렉토리에 복사되는 파일 및 디렉토리 위치
- `CREATE_MAIL_SPOOL=yes`: mail 사서함 생성 여부


<br/>
<br/>

## sh와 bash의 차이

| 항목            | `/bin/sh` (Bourne Shell)     | `/bin/bash` (Bourne Again Shell)  |
|-----------------|-----------------------------|----------------------------------|
| **출시 시기**   | 1979년 (Unix 초기 버전)      | 1989년 (Bourne Shell의 확장판)    |
| **기능**        | 기본적인 명령어 실행, POSIX 표준 | 고급 기능 (명령어 자동 완성, 배열, 명령어 기록 등) |
| **호환성**      | 더 많은 Unix 계열 시스템에서 동작  | 대부분의 Linux 시스템에서 사용 가능하지만, 호환성은 sh보다 적음 |
| **스크립트**     | 더 간단한 스크립트에 적합         | 복잡한 스크립트와 시스템 관리 작업에 적합  |
| **자동 완성**    | 지원하지 않음                  | 지원 (탭 키로 명령어 및 파일 이름 자동 완성) |
| **명령어 히스토리** | 기본적으로 지원하지 않음          | 히스토리 기능을 지원하여 이전에 입력한 명령어를 쉽게 재사용 가능 |
| **배열 지원**    | 지원하지 않음                  | 배열(Array) 사용 가능              |
| **일반적인 용도** | 간단한 스크립트, POSIX 준수 작업  | 복잡한 스크립트, 고급 시스템 관리 작업    |


- **출시 시기**: `/bin/sh`는 Unix 시스템에서 기본적으로 사용된 오래된 쉘로, 1979년에 처음 나왔고, 가장 단순하고 보편적인 쉘이다. 반면, **bash**는 1989년에 이 기본 쉘을 확장하고 더 많은 기능을 제공하기 위해 탄생했다.
  
- **기능 차이**: **bash**는 **sh**보다 훨씬 더 많은 기능을 제공한다. 특히, 배열 사용, 명령어 자동 완성, 히스토리 기능 등이 포함되어 있어 복잡한 스크립트를 작성할 때 유용하다. **sh**는 기본적인 명령어 실행과 간단한 스크립트 작성에 적합하며, 시스템 간의 호환성에 더 신경 쓰는 환경에서 많이 쓰인다.

- **호환성**: **sh**는 더 많은 Unix 계열 시스템에서 표준적으로 사용되기 때문에, 다양한 환경에서 동일하게 동작하는 **호환성**이 장점이다. 반면, **bash**는 더 많은 기능을 제공하지만, 모든 Unix 시스템에서 반드시 동일하게 동작하지 않을 수 있다.

- **스크립트 작성**: 간단한 명령어나 시스템에서의 자동화 작업에는 **sh**가 충분하지만, 복잡한 제어 흐름(예: `if`, `while`, `for`)이나 다양한 기능을 요구하는 작업은 **bash**가 더 적합하다.

- **자동 완성 및 히스토리 기능**: **bash**는 명령어 자동 완성과 명령어 히스토리를 기본적으로 제공한다. 이를 통해 사용자가 더 효율적으로 작업할 수 있도록 도와준다. 반면, **sh**는 이러한 편리한 기능이 부족하다.

- 결론적으로, **sh**는 더 가벼운 작업이나 호환성이 중요한 환경에서, **bash**는 복잡하고 고급 기능이 필요한 작업에서 적합하다고 할 수 있다.


<br/>
<br/>

## SELinux 

### SELinux란?
**SELinux(Security-Enhanced Linux)** 는 Linux 시스템에서 보안 정책을 통해 파일, 프로세스, 네트워크 자원에 대한 접근을 세밀하게 제어하는 보안 확장 모듈이다. 이를 통해 시스템 보안을 강화할 수 있다.

### SELinux의 제어과정
<img src="https://github.com/user-attachments/assets/e3db22a3-e3d7-473e-8190-b868a17c3f3a" width="400">

1. **AVC(Access Vector Cache)에서 요청 확인**:
   - 주체가 객체에 접근하려는 요청이 들어오면, **AVC**에서 이전에 같은 요청이 있었는지 확인한다.
   - 만약 이전에 처리된 요청이 있다면, 캐시된 결과를 사용하여 빠르게 결론을 내린다.

2. **주체가 객체에 대한 권한이 있는지 확인**:
   - SELinux는 **Security Policies(보안 정책)** 을 확인하여, 주체가 객체에 접근할 권한이 있는지 확인한다.
   - 보안 정책에 따라 주체가 할 수 있는 작업(읽기, 쓰기, 실행 등)을 결정한다.

3. **보안 정책에 따른 접근 허용 또는 차단 결정**:
   - **Security Policies**에 기반해 접근을 **허용**할지 **차단**할지 결정한다.
   - 주체가 정책에 맞는 권한을 가지고 있으면 접근이 허용되고, 그렇지 않으면 차단된다.

### 핵심 용어
- **주체(Subject)**: 접근을 시도하는 사용자 또는 프로세스.
- **객체(Object)**: 접근 대상(파일, 디렉토리, 네트워크 자원 등).
- **AVC(Access Vector Cache)**: 과거 요청의 결과를 캐시하여 빠르게 접근을 결정하는 공간.
- **Security Policies**: 시스템 관리자가 설정한 보안 규칙으로, 주체가 객체에 대한 접근 권한을 결정.



### `setenforce`란?
`setenforce`는 SELinux의 **실행 모드**를 설정하는 명령어로, 시스템의 보안 정책이 어떻게 적용되는지를 결정한다.

### SELinux 모드
SELinux는 주로 세 가지 실행 모드를 제공한다.

1. **Enforcing (강제 모드)**:
   - **SELinux 보안 정책이 강제적으로 적용**된다.
   - 정책에 어긋나는 액세스는 **차단**된다.
   - 예: 어떤 프로세스가 특정 파일에 접근할 수 없도록 정책이 설정되어 있다면, Enforcing 모드에서는 그 접근이 차단된다.

2. **Permissive (허용 모드)**:
   - 정책 위반이 발생해도 **접근이 허용**되지만, **로그에 기록**된다.
   - SELinux 정책을 디버깅하거나 테스트할 때 유용하다.

3. **Disabled (비활성화 모드)**:
   - **SELinux가 완전히 꺼진 상태**이다.
   - 정책이 전혀 적용되지 않는다.
   - `setenforce` 명령어로는 이 모드로 전환할 수 없으며, `/etc/selinux/config` 파일을 수정한 후 시스템을 재부팅해야 한다.

### `setenforce` 명령어 사용법

- **Enforcing 모드로 전환**:
    ```bash
    setenforce 1
    ```
    SELinux를 **Enforcing** 모드로 전환하여 정책을 강제 적용한다.

- **Permissive 모드로 전환**:
    ```bash
    setenforce 0
    ```
    SELinux를 **Permissive** 모드로 전환하여 정책 위반 사항을 허용하면서 로그에 기록한다.

### `getenforce` 명령어
현재 SELinux 모드를 확인할 때 사용하는 명령어로, **Enforcing**, **Permissive**, **Disabled** 중 현재 설정된 모드를 출력한다.

- **SELinux 모드 확인**:
    ```bash
    getenforce
    ```

### 실제 사용 사례
- **시스템 디버깅**: SELinux 정책으로 인해 서비스가 정상적으로 작동하지 않을 경우, 일시적으로 **Permissive 모드**로 전환하여 로그를 기록하면서 원인을 파악할 수 있다.
- **보안 테스트**: SELinux 정책을 테스트할 때 **Permissive** 모드를 활용하여 정책 위반 상황을 기록하고, 실제로 차단하지 않으면서도 로그로 문제를 확인할 수 있다.
- **운영 환경**: 실제 서버 운영 시에는 보안 강화를 위해 SELinux를 **Enforcing 모드**로 유지하는 것이 일반적이다. 하지만 일부 애플리케이션이 SELinux와 충돌할 경우, 상황에 맞게 모드를 적절히 변경해야 한다.


<br/>
<br/>

## 전통적인 리눅스 권한 vs SELinux 비교해보기

### 1. 전통적인 리눅스 권한 (setuid, setgid, sticky bit)

- **setuid**:
  - 프로그램이 실행될 때, **해당 파일의 소유자** 권한으로 실행.
  - 예: `passwd` 프로그램은 root 권한으로 실행되어 시스템 파일 수정 가능.

- **setgid**:
  - 파일이나 디렉토리를 **그룹 권한**으로 실행하거나 접근.
  - 디렉토리에 적용 시, 생성되는 파일들이 그 디렉토리의 그룹 소유권을 상속.

- **sticky bit**:
  - 디렉토리에서 **자신이 만든 파일만 삭제** 가능.
  - 예: `/tmp` 디렉토리에서 여러 사용자가 파일을 만들 수 있지만, 만든 사람만 삭제 가능.

#### 전통적인 권한의 특징
- **보안 모델**: DAC (Discretionary Access Control)
- **권한 관리 주체**: 파일 소유자와 그룹
- **적용 대상**: 파일과 디렉토리
- **주 사용 목적**: 간단한 권한 관리 및 접근 제어
- **세밀한 제어**: 상대적으로 제한적

<br/>

### 2. SELinux

- **SELinux**는 리눅스 커널에 내장된 **보안 모듈**로, 더 세밀한 보안 정책을 제공.
- **MAC (Mandatory Access Control)** 기반으로 작동하여, 사용자가 설정한 권한보다 더 강력한 정책을 적용.
- 정책을 통해 프로세스, 파일, 네트워크 자원 등의 접근을 **더욱 세밀하게 제어**할 수 있음.

#### SELinux의 특징
- **보안 모델**: MAC (Mandatory Access Control)
- **권한 관리 주체**: 시스템 관리자 또는 보안 정책
- **적용 대상**: 시스템 전체 (파일, 프로세스, 네트워크 등)
- **주 사용 목적**: 복잡한 보안 환경에서 전체 시스템 보안 강화
- **세밀한 제어**: 매우 세밀한 보안 정책 적용 가능

<br/>

### 3. 전통적인 리눅스 권한 vs SELinux 비교

| 항목                   | 전통적인 리눅스 권한 (setuid, setgid, sticky bit) | SELinux |
|------------------------|-------------------------------------------------|---------|
| **보안 모델**           | DAC (Discretionary Access Control)              | MAC (Mandatory Access Control) |
| **권한 관리 주체**      | 파일 소유자와 그룹                              | 시스템 관리자 또는 보안 정책 |
| **적용 대상**           | 파일과 디렉토리                                | 시스템 전체 (파일, 프로세스, 네트워크) |
| **세밀한 제어 가능성**  | 제한적                                        | 매우 세밀한 정책 적용 가능 |
| **보안 적용 범위**      | 특정 파일/디렉토리에 한정                      | 전체 시스템 보안 강화 |
| **사용 목적**           | 간단한 권한 관리 및 접근 제어                   | 복잡한 보안 환경에서 전체 시스템 보호 |

<br/>

### 4. 결론

- **전통적인 리눅스 권한 관리 방식**은 **setuid, setgid, sticky bit** 등을 사용하여 파일 및 디렉토리의 접근을 간단하게 제어하는 데 유용함.
- **SELinux**는 더 **복잡하고 민감한 보안 요구**에 대응하기 위한 강력한 보안 모듈로, 시스템 전반에 걸친 세밀한 보안 제어를 가능하게 함.
- **두 방식은 서로 보완적**이며, 전통적인 권한 방식은 간단한 보안 관리에, SELinux는 고급 보안 요구 사항을 충족하기 위한 도구로 사용됨.

