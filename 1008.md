##  네트워크 복습 (Ethernet, DNS, IPv4, IPv6, 서브넷 마스크)

### Ethernet

<img src="https://github.com/user-attachments/assets/c43f47c9-58f1-42ce-ad4c-68d62dcde672" width="400">

- 이더넷은 **유선 네트워크 기술**로, 컴퓨터와 네트워크 장치들이 데이터를 주고받는 **물리적 경로**를 제공하는 표준이다.
- 주로 LAN(Local Area Network)에서 많이 사용되며, 데이터는 이더넷 케이블을 통해 전달된다.
- 이더넷은 **도로망**과 같으며, 데이터는 도로를 따라 이동하는 **자동차**처럼 케이블을 통해 이동한다.
- **기능**: 안정적이고 빠른 데이터 전송, 충돌 방지(CSMA/CD 메커니즘), 다양한 속도 지원(100Mbps ~ 1Gbps 이상).

<br/>

### DNS (Domain Name System)

<img src="https://github.com/user-attachments/assets/c3d563b6-9d4e-49cd-935d-4efd64139190" width="400">

- DNS는 **도메인 이름**을 **IP 주소**로 변환해주는 시스템이다. 인터넷에서 웹사이트에 접속할 때, 사람이 이해하기 쉬운 도메인 주소를 숫자로 이루어진 IP 주소로 변환하여 적절한 서버와 연결해준다.
- DNS는 **전화번호부**와 같아서, 우리가 도메인 이름(사람의 이름)을 입력하면, 그에 해당하는 IP 주소(전화번호)를 찾아 연결해준다.

<br/>

### IPv4
- IPv4는 **32비트** 주소 체계를 사용하여 약 **43억 개**의 고유한 IP 주소를 제공하는 인터넷 프로토콜이다.
- **주소 예시**: `192.168.0.1`
- **제한**: IPv4 주소가 고갈됨에 따라 새로운 주소 체계인 IPv6가 도입되었다.

### IPv6
- IPv6는 **128비트** 주소 체계를 사용하며, 사실상 무한에 가까운 수의 고유한 IP 주소를 제공한다. **IPv4 주소 고갈 문제**를 해결하기 위해 도입되었다.
- **주소 예시**: `2001:0db8:85a3:0000:0000:8a2e:0370:7334`
- **이점**: 더 많은 주소, 향상된 보안 및 성능.

<br/>

### Subnet Mask (서브넷 마스크)

<img src="https://github.com/user-attachments/assets/7bf48eaf-4e5d-4f94-9a87-bc2b567be3d2" width="400">

- 서브넷 마스크는 IP 주소를 네트워크 부분과 호스트 부분으로 나누기 위한 도구이다. 네트워크 상에서 IP 주소를 효율적으로 관리하고 분배하기 위해 사용된다.
- **주소 예시**: `255.255.255.0`
- **기능**: 네트워크 내에서 IP 주소를 나눠서 소규모 네트워크(서브넷)로 구분하고, 데이터를 적절한 장치로 라우팅할 수 있게 한다.
- 서브넷 마스크는 **주소를 나누는 우편번호 체계**와 같아서, 각 지역을 구분하고 데이터를 올바른 지역으로 배달하게 한다.

<br/>
<br/>

## 하이퍼바이저 복습

<img src="https://github.com/user-attachments/assets/5aa5fe16-83cf-4235-bc79-3390b8b0af78" width="500">

- type2는 기본적으로 하드웨어와 하이퍼바이저에 운체가 한 번 껴있기 때문에 오버헤드 발생함
- 그렇다보니 type2는 테스트용, 실습용으로 쓰고 현업에서는 type1을 씀

<br/>

## DHCP (Dynamic Host Configuration Protocol)

<img src="https://github.com/user-attachments/assets/b8bac208-4621-4e7c-9e52-b0a552175064" width="400">

- DHCP는 네트워크에서 **IP 주소를 자동으로 할당**해주는 프로토콜이다.
- **자동화된 IP 주소 할당**: DHCP 서버는 네트워크에 새로운 장치가 연결될 때마다 IP 주소를 자동으로 배정하고, 필요한 네트워크 설정(게이트웨이, 서브넷 마스크, DNS 서버 등)을 전달한다.
  
  ### DHCP 동작 과정:
  1. **Discover**: 클라이언트가 네트워크에 연결되면, DHCP 서버에게 IP 주소 요청 신호를 보냄.
  2. **Offer**: DHCP 서버는 사용 가능한 IP 주소를 클라이언트에게 제안.
  3. **Request**: 클라이언트가 제안된 IP 주소를 요청.
  4. **Acknowledge**: DHCP 서버가 요청된 IP 주소를 확인하고 할당 완료.

- DHCP는 호텔 리셉션과 같아서, 호텔에 온 손님에게 방 번호(IP 주소)를 배정해주는 것과 같다.
- **장점**: 
  - 네트워크 관리자가 수동으로 IP 주소를 할당할 필요가 없어 관리하기 좋다.
  - 중복된 IP 주소 문제나 충돌을 방지하며, IP 주소를 동적으로 할당 및 회수하여 자원을 효율적으로 사용할 수 있다.


<br/>
<br/>


## 가상화의 종류 - 전가상화(Full Virtualization), 반가상화(Para Virtualizatoin), 하드웨어 지원 가상화(Hardware-assisted Virtualization)


<img src="https://github.com/user-attachments/assets/764ac237-b6f3-4d5c-aab2-b329fc778b2d" width="500">


### 1. 전가상화 (Full Virtualization)
- **전가상화**는 하이퍼바이저가 운영체제에 **완전히 독립된 가상 환경**을 제공하는 방식이다.
- 운영체제는 가상화된 하드웨어가 아닌 **가상 하드웨어**를 사용하며, 하드웨어와의 직접적인 상호작용을 하지 않는다. 운영체제는 가상화된 환경을 인식하지 못하고, 실제 하드웨어에서 실행되는 것처럼 동작한다.
- **특징**: 운영체제 수정 없이 가상화 가능. 물리적 하드웨어 위에서 가상 하드웨어로 실행.
- 전가상화에서는 하이퍼바이저가 하드웨어 자원을 가상화하여 가상 머신에 제공하기 때문에, 하드웨어 명령어를 변환하는 과정에서 오버헤드가 발생할 수 있다.
- 특히, 운영체제는 자신이 가상화된 환경에 있다는 것을 모르기 때문에, 하드웨어 명령어를 직접 실행하려고 시도한다. 이때 하이퍼바이저가 중간에서 이를 가상 하드웨어 명령어로 변환하는 작업(예: Binary Translation)을 수행해야 한다. -> 오버헤드 높은편
- **예시**: VMware, Microsoft Hyper-V, KVM.

### 2. 반가상화 (Paravirtualization)
- **반가상화**는 운영체제가 가상화된 환경을 인식하고 협조하는 방식이다. 운영체제는 가상화된 하드웨어 자원을 효율적으로 사용하기 위해 하이퍼바이저와 상호작용할 수 있다.
- **특징**: 운영체제를 수정해야 하며, 수정된 운영체제는 하이퍼바이저와 협력해 자원 관리 효율성 증가.
- 운영체제가 가상화된 환경을 인식하고 하이퍼바이저와 협조하여 자원을 관리하기 때문에, 하드웨어 명령어 변환 없이 하이퍼바이저와 상호작용할 수 있다 따라서 오버헤드는 낮은편
- **예시**: Xen 반가상화.

### 3. 하드웨어 지원 가상화 (Hardware-assisted Virtualization)
- **하드웨어 지원 가상화**는 CPU나 칩셋 같은 **하드웨어 자체에서 가상화 기능을 제공**하는 방식이다.
- 하드웨어가 가상화를 직접 지원하므로, 운영체제 수정 없이도 성능이 뛰어난 가상화 환경을 제공할 수 있다. 현대의 대부분의 가상화 솔루션은 이 방식을 사용한다.
- **특징**: 하드웨어의 지원을 받아 운영체제 수정 없이 효율적이고 빠른 가상화 가능.
- 하드웨어 지원 가상화에서는 CPU나 칩셋이 직접 가상화 기능을 지원한다.
- CPU가 가상화 명령어를 직접 처리할 수 있기 때문에, 하드웨어 명령어 변환이나 중재가 거의 필요하지 않아서 오버헤드가 거의 없고, 성능 저하가 최소화된다.
- **예시**: 인텔 VT-x, AMD-V, VMware ESXi, KVM.

### 비교
- **전가상화 (Full Virtualization)**: 운영체제는 가상화를 인식하지 못하고, 가상 하드웨어에서 실행됨. 오버헤드 높은편
- **반가상화 (Paravirtualization)**: 운영체제가 가상화를 인식하고 자원 관리를 최적화함. 운영체제 수정 필요. 오버헤드 낮은편
- **하드웨어 지원 가상화 (Hardware-assisted Virtualization)**: 하드웨어가 직접 가상화를 지원하여 운영체제 수정 없이도 효율적인 가상화 제공. 오버헤드 거의 없는 편

<br/>
<br/>

## SSH 공개키 인증 방식

### SSH 공개키 인증이란?
- SSH 공개키 인증은 **비밀번호 대신** **공개키/개인키** 쌍을 사용하여 네트워크 상에서 보다 **안전하게 서버에 접속**하는 방식이다.
- 이 방식은 클라이언트와 서버 간에 비밀 키를 주고받지 않고, **암호화된 키**를 사용하여 보안을 강화한다.

### 1. 키 쌍 생성
- 클라이언트는 공개키와 개인키 쌍을 생성한다. 공개키는 서버에 등록되고, 개인키는 클라이언트만이 가지고 있다.
- **명령어 예시**: `ssh-keygen -t rsa`

### 2. 공개키 등록
- 생성된 **공개키**를 서버에 등록한다. 서버의 `~/.ssh/authorized_keys` 파일에 공개키를 추가하여, 클라이언트의 인증을 허용할 준비를 한다.

### 3. SSH 접속
- 클라이언트가 SSH로 서버에 접속하려고 시도하면, 서버는 **무작위로 생성한 암호화된 메시지**를 클라이언트에게 보낸다.

### 4. 메시지 복호화
- 클라이언트는 자신의 **개인키(private key)** 를 사용해 메시지를 복호화하고, 복호화된 메시지를 서버에 다시 전송한다.

### 5. 인증 및 접속 허용
- 서버는 클라이언트가 전송한 복호화된 메시지를 확인하고, 클라이언트가 올바른 **개인키**를 소유하고 있음을 인증한 후, SSH 접속을 허용한다.


### SSH 공개키 인증의 장점
- **비밀번호가 필요 없음**: 비밀번호 없이 개인키를 통해 인증을 진행하므로, 네트워크 상에서 비밀번호가 유출될 위험이 없다.
- **보안 강화**: 개인키는 클라이언트만이 소유하고 있으며, 서버는 이를 통해 클라이언트를 신뢰성 있게 인증할 수 있다.
- **중간자 공격 방지**: 비밀번호 없이 암호화된 메시지와 키를 주고받는 방식이므로, 네트워크를 통한 공격에 강하다.


### SSH 공개키 인증 시퀀스 다이어그램

<img width="964" alt="image" src="https://github.com/user-attachments/assets/f45cd732-f85b-4a5d-8c64-07302fc7b720">
![image](https://github.com/user-attachments/assets/2de635ad-eef0-4cb8-bd84-c0c7cccd89c6)







